

\documentclass[12pt, letterpaper]{article}

\setlength{\topmargin}{-1.75cm} \setlength{\textheight}{22.5cm}
\setlength{\oddsidemargin}{0.25cm}
\setlength{\evensidemargin}{0.25cm} \setlength{\textwidth}{16.2cm}
\renewcommand{\figurename}{Table}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage[normalem]{ulem}
\usepackage{fontenc}
\usepackage{hyperref}
\usepackage{footnote}

\usepackage{palatino, url, multicol, listings} % for multiple columns
\lstset{mathescape=true, basicstyle=\ttfamily,}

%\usepackage{pictex}
%% in the .pictex output of xfig, there is command \colo
%% however the old version of pictex may not define this
%% so we define color here as empty
%\def \color#1]#2{}

\begin{document}

\newcommand{\hide}[1]{}
\newcommand{\exercise}[1]{}
\newcommand{\future}[1]{}
\newcommand{\otherquestions}[1]{}
\newcommand{\set}[1]{\{#1\}}
\newcommand{\pg}[1]{{\tt #1}}
\newtheorem{definition}{Definition}
\newcommand{\emptyclause}{\Box}
\def\st{\bigskip\noindent}
\newcommand{\lplus}
{
   \stackrel{+}{\gets}
}

\newcommand{\fe}[1] {
  \begin{frame}
    #1
  \end{frame}}

\newcommand{\eoa}{ {\bf End} of algorithm}

\newcommand{\ft}[1] {\frametitle{#1}}

\newcommand{\ie}[1] {
  \begin{itemize}
    #1
  \end{itemize}
}

\newcommand{\ee}[1] {
  \begin{enumerate}
    #1
  \end{enumerate}\label{marker}
}
\newcommand{\blk}[2] {
  \begin{block}{#1}
    #2
  \end{block}
}

\newtheorem{collorary}{Corollary}
\newtheorem{proposition}{Proposition}
\newtheorem{invariant}{Invariant}
\newtheorem{property}{Property}
\newtheorem{claim}{Claim}
\newtheorem{example}{Example}


\title{${\cal SPARC}$ manual}
\date{\today}
\maketitle
\tableofcontents
\pagebreak
\section{Introduction}
A good knowledge representation methodology should allow one to:
\begin{itemize}
\item Identify and describe \emph{sorts} (types, kinds,
categories) of objects
populating a given domain.
\item Identify and precisely
define important \emph{properties} of these objects and
\emph{relationships} between them.
\end{itemize}
An \emph{abstract model} of the
domain will consist of sorts
and definitions produced by this process.
To deal with a particular problem one needs to
describe relevant objects and their sorts
and properties and use
the corresponding inference engine to solve the problem.
ASP based knowledge representation languages have powerful
means for describing non-trivial properties of objects
but lack the means of conveniently specifying objects
and their sorts as well as sorts of parameters
of the domain relations and functions. There were some
recent attempts to remedy the problem but we do not believe
that a sufficiently simple and powerful solution has been
found so far. In this manual we describe a knowledge representation
language ${\cal SPARC}$ which attempts to solve this problem and provide some examples of using the system we implemented.

\section{System installation}
${\cal SPARC}$ system  works in two phases:
\begin{enumerate}
\item Translation of ${\cal SPARC}$ code to Answer Set Prolog (ASP) code.
\item Running ASP code on existing ASP solvers.
\end{enumerate}

\st So, to use the system you need two things:
\begin{enumerate}
\item The SPARC to ASP translator. It can be downloaded here: \url{https://github.com/iensen/sparc_paper/blob/master/sparc.jar?raw=true}.
\item An ASP solver. We recommend using DLV for best compatibility with out translator. DLV can be downloaded here:
 \url{http://www.dlvsystem.com/dlv/#1}
You need to download \textit{static} version of the executable file.

\end{enumerate}
To demonstrate usage of the system, let's start with simple example.
\begin{verbatim}
sorts
#person={bob,tim,andy}.
predicates
teacher(#person).
rules
teacher(bob).
\end{verbatim}

\st This is a SPARC program. It consists of three sections:
\begin{itemize}
 \item Sort definitions. The section starts with the keyword \textit{sorts} followed by definitions of the sorts in the program.
 \item Predicate declarations. The section starts with the keyword \textit{predicates} followed by declarations of predicates of the program.
 \item Program rules. The sections starts with the keyword \textit{rules}  and consists of a collection of rules satisfying ASP syntax.
\end{itemize}

\st To translate the program, run sparc.jar with arguments specifying the SPARC program and the file where the translation will put its result:
\begin{verbatim}
$ java -jar sparc.jar example.sp -o example.asp
SPARC to DLV translator V2.21
program translated
\end{verbatim}

\st To get the answer sets of the translated program, run DLV:

\begin{verbatim}
$ dlv example.asp
DLV [build BEN/Dec 21 2011   gcc 4.6.1]

{teacher(bob)}
\end{verbatim}

\st You should see that the answer set appeared. For a detailed description of ${\cal SPARC}$ system options, see 
\url{https://github.com/iensen/sparc_paper/wiki/System-usage}.

\st For Linux, MacOS or Cygwin (Windows) users we prepared a bash script which combines translation and solver execution into one step.
It is available here: \url{https://github.com/iensen/sparc/raw/master/sparc}. Before using the script, make it executable by running command
\texttt{chmod +x sparc} from the command line.

The general syntax is :
\begin{verbatim}
 sparc input_file [dlv_options]
\end{verbatim}
For the complete list of dlv options, see 
\url{http://www.dlvsystem.com/html/DLV_User_Manual.html }

Here is an example of using the script:
\begin{verbatim}
$ sparc example.sp -filter=teacher
...
{teacher(bob)}
\end{verbatim}
\st To see more examples of ${\cal SPARC}$ programs, visit \url{https://github.com/iensen/sparc_paper/wiki/Program-Examples}.
\section{Detailed System Description}

\subsection{Sort definitions}\label{ss}



\st \textit{Basic sorts} are defined as named collections of identifiers, i.e, strings consisting of
\begin{itemize}
 \item latin letters: $\{a,b,c,d,..,z,A,B,C,D,..,Z\}$
 \item digits: $\{0,1,2,..,9\}$
 \item underscore: $\_$
\end{itemize}
and either starting from a letter or containing only digits.

Non-basic sorts also contain \textit{records} of the form $id(\alpha_1,\dots \alpha_2)$, where id is an identifier and 
$\alpha_1, \dots \alpha_n$ are either identifiers or records. 


\st We define sorts by means of expressions(in what follows sometimes referred as statements) of five types:

\begin{enumerate}
 \item \textbf{set-theoretic expression}.
 \begin{verbatim}
  set_expression := #sort_name | {ground_term_list}
  set_expression := (set_expression) 
                    | (set_expression + set_expression ) 
                    | (set_expression * set_expression ) 
                    | (set_expression - set_expression )
  \end{verbatim}
The operations $+$ $*$ and $-$ stand for union, intersection and difference correspondingly.
\texttt{ground\_term\_list} is set of \textit{ground terms}, defined as follows:
\begin{itemize}
 \item numbers and constants are ground terms;
 \item If $f$ is an identifier and $\alpha_1, \dots \alpha_n$ are ground terms, then $f(\alpha_1,\dots \alpha_n)$ is a ground term.
\end{itemize}
\textit{Example} : 
\begin{verbatim}
 sort1={f(a),a,b,2}.
 sort2={1,2,3}$ + {a,b,f(c)} -  {f(a),a,b,2}.
\end{verbatim}
According to the definition, \texttt{sort1} consists of ground terms $\{f(a),a,b,2\}$, and \texttt{sort2} is $\{1,2,3,f(c)\}$ 

\item \textbf{numeric range}.
\begin{verbatim}
 numeric_range := number1 .. number2
\end{verbatim}

\textit{number1} should be smaller or equal than \textit{number2}. The expression defines the set 
of subsequent numbers $\{number1, number1+1, \dots number2\}$

\textit{Example:}

\begin{verbatim}
 sort1=1..3
\end{verbatim}
\texttt{sort1} consists of numbers $\{1,2,3\}$.


\item \textbf{identifier range}


\begin{verbatim}
 id_range := id1 .. id2
\end{verbatim}

\textit{id1} should be lexicographically smaller or equal than \textit{id2}. 
\textit{id1} and \textit{id2} should both consist of digits and letters.
The expression defines the set of all strings \\ S=$\{s: id1\leq s \leq id2 \land |id1|\leq |s| \leq |id2|\}$



\textit{Example:}

\begin{verbatim}
 sort1=a..f.
\end{verbatim}
\texttt{sort1} consists of latin letters $\{a,b,c,d,e,f\}$.

\item \textbf{concatenation}
\begin{verbatim}
concatenation := [b_stmt_1] .. [b_stmt_n]
\end{verbatim}

\texttt{b\_stmt\_1}, $\dots$, \texttt{b\_stmt\_n} must be \textit{basic statements}, defined as follows:


\begin{itemize}
 \item statements of the forms (2)-(4) are basic
 \item statement $S$ of the form (1) is basic if:
 \begin{itemize}
  \item all curly brackets occurring in $S$ contain only constants consisting of latin letters and digits
  \item all sorts occurring in $S$ are defined by basic statements 
 \end{itemize}
\end{itemize}
Note that basic statement can only define a basic sort not containing records.

\textit{Example:}

\begin{verbatim}
 sort1=[b][1..100].\footnote{We allow a shorthand `b` for singleton  set \{b\}}.
\end{verbatim}

\texttt{sort1} consists of identifiers $\{b1,b2,\dots b100\}$.


\item \textbf{record}


\begin{verbatim}
 functional_term := f(sort_name1(var_1),.., sort_namen(var_n)):
                                     condition(var_1,..,var_n)
 condition(var_1,..,var_n) := var_i REL var_j 
 condition(var_1,..var_n) :=   condition and condition 
              | condition or condition 
              | not(condition) 
              | (condition)
\end{verbatim}
Variables \texttt{var\_1,..var\_n} are optional.
Condition can only contain variables from the list \texttt{var\_1,..var\_n}.
If there is a subcondion \texttt{var\_i REL var\_j}, where REL is either $\{>,\geq,<,\leq\}$ then \texttt{sortname\_i} and then \texttt{sortname\_j}
must be defined by basic statements.

The expression defines a collection of ground terms \\ $\{f(t_1,\dots,t_n): condition(t_1,\dots t_n)~is~true\}$

\textit{Example}
\begin{verbatim}
 #s=1..2.
 #sf=f(s(X),s(Y),s(Z)): (X=Y or Y=Z). 
\end{verbatim}

The sort \texttt{sf} consists of records $\{f(1,1,2),f(1,1,1),f(2,1,1)\}$

\end{enumerate}

\subsection{Predicate Declarations}

\noindent  The second part of a  ${\cal SPARC}$ program starts with the keyword
\st
$predicate\ declarations$

\st and is followed by statements of the form

\st
$pred\_symbol(sortName,\dots,sortName)$

\st

Multiple declarations for one predicate symbol are not allowed.
\st For any sort name $SN$, the system includes declaration  $SN(SN)$ automatically.

\subsection{Program Rules}


\st The third part of a ${\cal SPARC}$ program consists of standard ASP rules and/or consistency restoring (cr)-rules.
\st
CR-rules are of the following form:

\begin{equation}
   [label:] l_0 \lplus l_1,  \ldots, l_k, not~l_{k+1} \ldots not~l_{n}
 \end{equation}
where $l$'s are literals.
Literals occurring in the heads of the rules must not be formed by predicate symbols
occurring as sort names in sort definitions.
\section{Directives}
Directives should be written before sort definitions, at the very beginning of a program.
${\cal SPARC}$ allows two types of directives:
\subsection{\#maxint}
Directive \#maxint specifies maximal nonnegative number which could be used in arithmetic calculations. For example,
\begin{verbatim}
 #maxint=15.
\end{verbatim}
\st limits integers to [0,15].
\subsection{\#const}
Directive \#const allows one to define constant values. The syntax is:
\begin{verbatim}
   #const constantName = constantValue.
\end{verbatim}      
\st where $constantName$  must begin with a lowercase letter and may be composed of letters, underscores and digits,
 and $constantValue$ is either a nonnegative number or the name of another constant defined above.  
\section{Answer Sets}
\noindent A set of ground literals $S$ is an {\em answer set} of a ${\cal SPARC}$ 
program $\Pi$ with regular rules only if $S$ is an answer set of an ASP program consisting of the same rules.

\st To define the semantics of a general ${\cal SPARC}$ program, we need notation for abductive support.
By $\alpha(r)$ we denote a regular rule
obtained from a consistency restoring rule $r$
by replacing $\lplus$ by $\leftarrow$;
$\alpha$ is expanded in the standard way to a set $X$ of CR-rules,
i.e., $\alpha(A) = \{\alpha(r)\; :\; r \in A\}$.
\st A %minimal (with respect to the preference relation $\leq$ of the program)
collection $A$ of CR-rules of $\Pi$ such that
\begin{enumerate}
\item $R \cup \alpha(X)$ is consistent (i.e., has an answer set), and
\item any $R_0$ satisfying the above condition has cardinality
which is greater than or equal to that of $R$
\end{enumerate}
is called an {\em abductive support} of $\Pi$.
\st A set of ground literals $S$ is an {\em answer set} of a ${\cal SPARC}$ program 
$\Pi$ if $S$ is an answer set of $R \cup \alpha(A)$, where $R$ is the set of regular rules of $\Pi$, for some abductive
support $A$ of $\Pi$.

\st \textbf{Example}
\begin{verbatim}
sorts
#s1={a}.  % term "a" has sort "s1"

predicates
p(#s1).  %predicate  "p" accepts terms of sort s1 
q(#s1).  %predicate  "q" accepts terms of sort s1 

rules
p(a) :- not q(a).
-p(a).
q(a):+.  % this is a CR-RULE. 
\end{verbatim}
\st Result:
\begin{verbatim}
  ./sparc example2.sp
DLV [build BEN/Dec 21 2011   gcc 4.6.1]

SPARC to DLV translator V2.02
program translated
Best model: {-p(a), appl(r_0), q(a)}
Cost ([Weight:Level]): <[1:1]>

\end{verbatim}

\st Additional literal $appl(r_0)$ was added to the answer set, which means that the 
first cr-rule from the program was applied.
\section{Syntax checking}
During this phase the program is checking for satisfying  \href{https://github.com/iensen/sparc_paper/blob/master/SparcTranslator/parser/Sparc_grammar.txt}{${\cal SPARC}$ lexical and syntactical specifications}.
All found syntax errors are reported.
\section{Typechecking}
If no syntax errors, are found,  a static check program is performed all found type-related problems, classified into type errors and type errors.
\subsection{Type errors}
Type errors are considered as serious issues which make it  impossible to complied and execute the program.
Type errors can occur in all four section of a ${\cal SPARC}$ program.
\subsubsection{Sort definition errors}
\begin{enumerate}
\item  Set-theoretic expression (statement (2) in section \ref{ss}) contains a name of undefined sort.

\textit{Example:}
\begin{verbatim}
 sorts
 #s={a}.
 #s2=#s1-s.
\end{verbatim}

\item  Sort with the same name is defined more than once.
\textit{Example:}
\begin{verbatim}
 sorts
 #s={a}.
 #s={b}.
\end{verbatim}


\item In an identifier range id1.. id2 (statement (2) in section \ref{ss}) the first identifier(id1) is lexicographically greater than id2.
\textit{Example}
\begin{verbatim}
 sorts
 #s=zbc..cbz.
\end{verbatim}

\item In a numeric range $n1..n2$ (statement (2) in section \ref{ss})  n1 is greater than n2.
\textit{Example:}
\begin{verbatim}
 sorts
 #s=100500..1.
\end{verbatim}


\item Numeric range (statement (2) in section \ref{ss}) $n1..n2$  contains an undefined constant.

\begin{verbatim}
 #const n1=5.
 sorts
 #s=n1..n2.
\end{verbatim}

\item In an identifier range $id1..id2$ (statement (3) in section \ref{ss})  the length of the first identifier(id1) is greater than length of the second. 


\textit{Example:}
\begin{verbatim}
 sorts
 #s=abc..a.
\end{verbatim}

\item Concatenation (statement  (4) in section \ref{ss}) contains a non-basic sort.

\textit{Example:}
\begin{verbatim}
 sorts
 #s={f(a)}.
 #sc=[a][#s].
\end{verbatim}



\item Record definition (statement (5) in section \ref{ss}) contains an undefined sort.

\textit{Example:}
\begin{verbatim}
 sorts
 #s=1..2.
 #fs=f(s,s2).
\end{verbatim}



\item Definition of record (statement (5) in section \ref{ss}) contains a condition with relation $>,<,\geq,\leq$ such that the
   corresponding sorts are not basic.
\textit{Example:}
\begin{verbatim}
#s={a,b}.
#s1=f(#s). 
#s2=g(s1(X),s2(Y)):X>Y.
\end{verbatim}

\item  Variable is used more than once in record definition(statement  (5) in section \ref{ss}).

\textit{Example:}

\begin{verbatim}
 sorts
 #s1={a}.
 #s=f(#s1(X),#s1(X)):(X!=X).
\end{verbatim}
\item Sort contains an empty collection of ground terms.

\textit{Example}
\begin{verbatim}
 sorts
 #s1={a,b,c}
 #s=#s1-{a,b,c}.
\end{verbatim}
\end{enumerate}
\subsubsection{Predicate declarations errors}

\begin{enumerate}
\item A predicate with the same name is defined more than once.
\textit{Example:}
\begin{verbatim}
 sorts
 #s={a}.
 predicates
 p(#s).
 p(#s,#s).
\end{verbatim}
\item A predicate declaration contains an undefined sort.
\textit{Example:}
\begin{verbatim}
 sorts
 #s={a}.
 predicates
 p(#ss).
\end{verbatim}
\end{enumerate}
\subsubsection{Program rules errors}

In program rules we first check each atom of the form $p(t_1,\dots,t_n)$ and each term occurring in the program $\Pi$ for satisfying
the definitions of program atom and program term correspondingly(!!add reference as soon as it is available). Moreover, we check that no sort occurs in a head of a rule of $\Pi$.
\subsection{Type warnings}
During this phase each rule in input ${\cal SPARC}$ program is checked for having at least one ground instance. This is done by applying a standard constraint
satisfaction algorithm to a constraint formula over finite domains[9] produced by algorithms from (!!! add link as soon as it is available).
Warnings are reported for the rules which have no ground instances.

\section{${\cal SPARC}$ and Unsafe Rules}

${\cal SPARC}$ helps to avoid \textit{unsafe rule} errors in most  cases.
\st \textbf{Example.}
\begin{verbatim}
sort definitions
s1=1..5.
predicate declarations
p(s1).
program rules
p(X). 
\end{verbatim}
The only rule in the program is unsafe (variable X does not occur in the body).
However, by translating the program and running ASP solver, we will be able to avoid this unsafety 
(with addition of auxiliary predicates).
Here is the execution trace:
\begin{verbatim}
$ ./sparc example3.sp -pfilter=p 
DLV [build BEN/Dec 21 2011   gcc 4.6.1]

SPARC to DLV translator V2.02
program translated
{p(1), p(2), p(3), p(4), p(5)}
\end{verbatim}
\section{${\cal SPARC}$ and ASPIDE}
TODO. 

\end{document}