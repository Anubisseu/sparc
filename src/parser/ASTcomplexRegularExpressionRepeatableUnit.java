/* Generated By:JJTree: Do not edit this line. ASTcomplexRegularExpressionRepeatableUnit.java Version 4.3 */
/* JavaCCOptions:MULTI=true,NODE_USES_PARSER=false,VISITOR=true,TRACK_TOKENS=false,NODE_PREFIX=AST,NODE_EXTENDS=,NODE_FACTORY=,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
package parser;


public
class ASTcomplexRegularExpressionRepeatableUnit extends SimpleNode implements Cloneable{
  // The class represents a node of a syntax tree.
  // Tree structure:
  // ...
  // ComplexRegularExpression: 	
  //  ASTcomplexRegularExpressionRepeatableUnit:
  //    ASTcomplexRegularExpressionUnit
  //    Repetition//?
	


  public ASTcomplexRegularExpressionRepeatableUnit(int id) {
    super(id);
  }


  public ASTcomplexRegularExpressionRepeatableUnit(SparcTranslator p, int id) {
    super(p, id);
  }

  public boolean split()
  {
	  
	  
	  if(this.jjtGetNumChildren()==2)
	  {
		  if(((SimpleNode)this.jjtGetChild(1)).image.contains(","))
		  {
			  ASTcomplexRegularExpression AncestorComplex=(ASTcomplexRegularExpression)this.parent;
			  ASTcomplexRegularExpressionChoices AncestorChoice=(ASTcomplexRegularExpressionChoices)((ASTcomplexRegularExpression)parent).parent;
			  int place=-1;
			  for(int i=0;i<AncestorChoice.jjtGetNumChildren();i++)
			  {
				  if(AncestorChoice.jjtGetChild(i)==AncestorComplex)
				  {
					  place=i;
				  }
			  }
			  
			  int repetableUnitPlace=-1;
			  for(int i=0;i<AncestorComplex.jjtGetNumChildren();i++)
			  {
				  if(AncestorComplex.jjtGetChild(i)==this)
				  {
					  repetableUnitPlace=i;
				  }
			  }
			  
			  String []range=((ASTrepeatition)(this.jjtGetChild(1))).image.split(",");
			  int from=Integer.parseInt(range[0]);
			  int to=Integer.parseInt(range[1]);
			 // AncestorChoice.dump("before: ");
			  AncestorChoice.removeIthChild(place);
			//  AncestorChoice.dump("after: ");
			 // System.out.println(place);
			  for(int i=from;i<=to;i++)
			  {
				  ASTcomplexRegularExpression AncestorComplexClone=new ASTcomplexRegularExpression(AncestorComplex);
				  ((SimpleNode)AncestorComplexClone.jjtGetChild(repetableUnitPlace).jjtGetChild(1)).image=Integer.toString(i);
			
				  AncestorChoice.jjtAddNodeInside(AncestorComplexClone, place++);
				  AncestorComplexClone.parent=AncestorChoice;
				//  System.out.println(">>>>");
				 
				 // System.out.println("<<<<");	  
				  
			  }
			//  AncestorChoice.dump("after paste: ");
			

			  /*
			  String []range=((ASTrepeatition)(this.jjtGetChild(1))).image.split(",");
			  int from=Integer.parseInt(range[0]);
			  int to=Integer.parseInt(range[1]);
			  ((SimpleNode)this.jjtGetChild(1)).image=range[0];
			  for(int i=from+1;i<=to;i++)
			  {
				  ((SimpleNode)this.jjtGetChild(1)).image=Integer.toString(i);
                  ASTcomplexRegularExpression complexClone=(ASTcomplexRegularExpression) (cloner.deepClone(this.parent));
                  complexClone.parent=null; // we probably don't want to clone the whole tree!!!!!!
                  complexClone.parent=((SimpleNode)parent).parent;// but we still need  parents:(
				  ((SimpleNode)this.parent).parent.jjtAddChild(complexClone, ((SimpleNode)this.parent).parent.jjtGetNumChildren());  
			  }
			  
			  ((SimpleNode)this.jjtGetChild(1)).image=range[0];
			  */
			//  this.dump("this: ");
			 // ((SimpleNode) ((SimpleNode) this.parent).parent).dump("praparent: ");
		  }
		  
		  else
		  {
		    int count=Integer.parseInt(((ASTrepeatition)(this.jjtGetChild(1))).image);
		    ASTcomplexRegularExpression ancestor=(ASTcomplexRegularExpression)this.parent;
		    //this.dump("GG");
		   // ancestor.dump("FF");
		   // ((SimpleNode) ancestor.parent).dump("TT");
		   // ((SimpleNode) ((SimpleNode) ancestor.parent).parent).dump("UU");
		    int place=-1;
		    for(int i=0;i<ancestor.jjtGetNumChildren();i++)
		    {
		    	if(parent.jjtGetChild(i)==this)
		    	{
		    		place=i;
		    	}
		    }
		    ancestor.removeIthChild(place);
		    for(int i=0;i<count;i++)
		    {
		      ASTcomplexRegularExpressionRepeatableUnit repunit=new ASTcomplexRegularExpressionRepeatableUnit(SparcTranslatorTreeConstants.JJTCOMPLEXREGULAREXPRESSIONREPEATABLEUNIT);
		      repunit.jjtAddChild(this.jjtGetChild(0), 0);
		      repunit.parent=ancestor;
		      ancestor.jjtAddNodeInside(repunit, place++);
		    }
		    /*
		    this.removerightMostChild();
		    if(count ==0)
		    {
		    	((SimpleNode)this.jjtGetChild(0)).image="";
		    }
		    
		    for(int i=1;i<count;i++)
		    {
		    
		      ASTcomplexRegularExpressionRepeatableUnit node = (ASTcomplexRegularExpressionRepeatableUnit) (cloner.deepClone(this));
		      node.parent=null;

		      ancestor.jjtAddNodeInside(node, place++);
		      node.parent=ancestor;
		    }
		    */
		  
		  }
		  return false;
	  }
	  return false;
  }
  
  

  /** Accept the visitor. **/
  public Object jjtAccept(SparcTranslatorVisitor visitor, Object data) {
    return visitor.visit(this, data);
  }
}
/* JavaCC - OriginalChecksum=f5a2088be5fca1e30b860ab3449e55d5 (do not edit this line) */
