//TODO: change extendedNonRelAtom to extendedAtom.
options{  BUILD_PARSER = true;  STATIC = false;  OUTPUT_DIRECTORY = "/home/iensen/sparc_project/src/parser";  MULTI = true;  VISITOR = true;}PARSER_BEGIN(SparcTranslator)package parser;import java.io.*;import sorts.*;import java.util.HashMap;import java.util.ArrayList;import java.util.HashSet;import java.util.Scanner;import translating.Translator;import typechecking.TypeChecker;
import translating.InstanceGenerator;@ SuppressWarnings("all") public class SparcTranslator{  // mapping from sort names to sort expressions assigned to the sorts
  public HashMap < String, ASTsortExpression > sortNameToExpression;  // mapping from predicate names to a list of names of sorts describing
  // arguments
  public HashMap < String, ArrayList < String >> predicateArgumentSorts;  // labels of cr-rules
  public HashSet < String > crRuleLabels;    //sort occurred explicitly in the program
  public HashSet < String > generatingSorts;  // mapping from constant names to their values.
  public HashMap < String, Long > constantsMapping;  // warnings found during the translation
  private ArrayList < String > warnings;  public static void main(String [] args)  {    int argc = args.length;    System.err.println("SPARC to DLV translator V2.10");    ArrayList < String > inputFiles = new ArrayList < String > ();    Reader sr = null;    Writer out = null;    // check for inappropriate arguments
    if (argc == 1 && (args [0].equals("-h") || args [0].equals("-help")     || args [0].equals("-H") || args [0].equals("-Help")))    {      show_usage();      return;    }    /* if first argument is provided and
       it is not -h -help -H -Help - it is the first input file*/    /* We read input files until we get -o or the end of args array*/    int currentArgIndex = 0;    // add input files
    while (currentArgIndex < args.length && !args [currentArgIndex].startsWith("-"))    {      inputFiles.add(args [currentArgIndex]);      ++currentArgIndex;    }    if (currentArgIndex < args.length && args [currentArgIndex].startsWith("-"))    {      /// name of output file should follow -o option
      if (!args [currentArgIndex].equals("-o") || currentArgIndex + 1 == args.length)      {        show_usage();        return;      }      ++currentArgIndex;      // check for existence
      if (new File(args [currentArgIndex]).exists() && !new File(args [currentArgIndex]).isDirectory())      {        System.err.println("the output file already exists , do you want to overwrite it? y/n:");        char rep;        try        {          rep = (char) System.in.read();        }        catch (IOException e)        {          e.printStackTrace();          return;        }        if (rep != 'y' && rep != 'Y')        {          return;        }      }      try      {        out = new FileWriter(args [currentArgIndex]);      }      catch (IOException e)      {        e.printStackTrace();      }    }    if (sr == null) sr = new InputStreamReader(System.in);    if (out == null) out = new OutputStreamWriter(System.out);    ;    try    {      int currentInputFileIndex = 0;      if (inputFiles.size() != 0)      {
        // read input from multiple files        try        {          sr = new FileReader(inputFiles.get(currentInputFileIndex));          ++currentInputFileIndex;        }        catch (FileNotFoundException fileException)        {          System.err.println("%INPUT FILE ERROR: " + fileException.getMessage());          return;        }      }      SparcTranslator p = new SparcTranslator(sr);      SimpleNode e = p.program();
      //process regular expression      RIdentifierSplitVisitor v = new RIdentifierSplitVisitor();      e.jjtAccept(v, null);      RRepeatitionRemover removeNMrepeatitions = new RRepeatitionRemover();      e.jjtAccept(removeNMrepeatitions, null);      RChoiceRemover choiceremover = new RChoiceRemover();      e.jjtAccept(choiceremover, null);
      InstanceGenerator gen = new InstanceGenerator(p.predicateArgumentSorts,
				p.sortNameToExpression);      TypeChecker tc = new TypeChecker(p.sortNameToExpression, p.predicateArgumentSorts, p.constantsMapping,gen);      Translator tr = new Translator(out, p,gen);
      // do typechecking of rules in the first file
      if (inputFiles.size() != 0)
      {
        tr.setInputFileName(getShortFileName(inputFiles.get(0)));
        tc.setInputFileName(getShortFileName(inputFiles.get(0)));
      }      tc.checkRules((ASTprogramRules) e.jjtGetChild(2));    
      // translate program in the first file      tr.translateProgram((ASTprogram) e, p.generatingSorts, (inputFiles.size() > 1) ? false : true);
      //process other files      for (int fileIndex = 1; fileIndex < inputFiles.size(); fileIndex++)      {        try        {          sr = new FileReader(inputFiles.get(fileIndex));        }        catch (FileNotFoundException fileException)        {          System.err.println("%INPUT FILE ERROR: " + fileException.getMessage());          ;          return;        }        p.ReInit(sr);        tr.setInputFileName(getShortFileName(inputFiles.get(fileIndex)));        tc.setInputFileName(getShortFileName(inputFiles.get(fileIndex)));        SimpleNode rules = p.programRules();
        //do typechecking of rules from other files        tc.checkRules((ASTprogramRules) rules);        /* we only write warnings after we translated the last file:*/        tr.translateAndWriteRules((ASTprogramRules) rules, fileIndex == inputFiles.size() - 1);      }    }    catch (ParseException pe)    {      System.err.println(pe.getMessage());      ;      return;    }    System.err.println("program translated");  }
  /**
  * @return file name without full path.
  */  private static String getShortFileName(String fullPath)  {    File file = new File(fullPath);    return file.getName();  }  /**
  * Output help message
  */  private static void show_usage()  {    System.err.println("usage0(reads from console and outputs to console): sparc");    System.err.println("usage1(reads from file and outputs to console): sparc input_file_1,...,input_file_n");    System.err.println("usage2(reads from file and outputs to file): sparc input_file_1,...,input_file_n -o output_file");  }  /**
  * Add built-in sorts to sort expressions
  */  public void addBuiltInSorts()  {    HashMap < String, ASTsortExpression > builtInSorts = BuiltInSorts.getBuiltInSorts();    for (String sortName : builtInSorts.keySet())    {      sortNameToExpression.put(sortName, builtInSorts.get(sortName));    }  }  /**
  * Add warning to set of warnings
  */  public void addWarning(String warning)  {    warnings.add(warning);  }  public ArrayList < String > getWarnings()  {    return warnings;  }}PARSER_END(SparcTranslator)< DEFAULT, IN_PROGRAM_RULES >TOKEN :{  < MAXINTDIRECTIVE : "#maxint" >|   < CONSTDIRECTIVE : "#const" >|   < SORTDEFKEYWORD : "sort" ([ "\r", "\n", "\t", " " ])+ "definitions" ([ "\r", "\t", " ", "\n" ])+ >|   < PREDDEFKEYWORD : "predicate" ([ "\r", "\n", "\t", " " ])+ "declarations" ([ "\r", "\t", " ", "\n" ])+ >|   < PROGRULDEFKEYWORD :     "program" ([ "\r", "\n", "\t", " " ])+ "rules" ([ "\r", "\t", " ", "\n" ])+ > : IN_PROGRAM_RULES|   < NOT : "not" ([ "\t", "\r", " " ])+ >|   < MOD : "mod" >|   < IDENTIFIER : [ "a"-"z" ] ([ "a"-"z", "A"-"Z", "0"-"9", "_" ])* >|   < VARIABLE :    (      [ "A"-"Z" ] ([ "a"-"z", "A"-"Z", "0"-"9", "_" ])*    | "_"    ) >|   < NONZERODIGIT : [ "1"-"9" ] >|   < POSITIVE_INTEGER :    < NONZERODIGIT >    (      < ZERO >    | < NONZERODIGIT >    )* >|   < ZERO : "0" >|   < PLUS : "+" >|   < MULT : "*" >|   < DIV : "/" >|   < EQ : "=" >|   < NOTEQ : "!=" >|   < GT : ">" >|   < GTEQ : ">=" >|   < SM : "<" >|   < SMEQ : "<=" >|   < OP : "(" >|   < CP : ")" >|   < OB : "{" >|   < CB : "}" >|   < ORRSEP : ":-" >|   < CRRSEP : ":+" >|   < WEAKSEP : ":~" >|   < COMMA : "," >|   < DOT : "." >|   < COLON : ":" >|   < SEMICOLON : ";" >|   < DOLLAR : "$" >|   < COMPLEMENT : "~" >|   < OR : "|" >|   < AGGREGATE_COUNT : "#count" >|   < AGGREGATE_SUM : "#sum" >|   < AGGREGATE_MIN : "#min" >|   < AGGREGATE_MAX : "#max" >}< DEFAULT >TOKEN :{  < SOB : "[" > : IN_REGULAREXPRESSIONSEQUENCE}< IN_REGULAREXPRESSIONSEQUENCE >TOKEN :{  < LETTER :    (      [ "A"-"Z" ]    | [ "a"-"z" ]    ) >|   < DIGIT : ([ "0"-"9" ]) >|   < SCB : "]" > : DEFAULT}< IN_PROGRAM_RULES >TOKEN :{  < IDENTIFIER_WITH_OP : [ "a"-"z" ] ([ "a"-"z", "A"-"Z", "0"-"9", "_" ])* ([ "\t", "\r", "\n" ])* "(" >|   < NEGATIVE_ATOM_WITH_OP : "-" [ "a"-"z" ] ([ "a"-"z", "A"-"Z", "0"-"9", "_" ])* ([ "\t", "\r", "\n" ])* "(" >|   < PARAM_END : "]" >|   < PARAM_BEGIN : "[" >}< DEFAULT, IN_PROGRAM_RULES, IN_REGULAREXPRESSIONSEQUENCE >SKIP :{  < SINGLE_LINE_COMMENT :    "%" (~[ "\n", "\r" ])*    (      "\r"    | "\n"    | "\r\n"    )? >|   < SPACE : ([ "\n", "\r", "\t", " " ])+ >}< DEFAULT, IN_PROGRAM_RULES, IN_REGULAREXPRESSIONSEQUENCE >TOKEN :{  < MINUS : "-" >}SimpleNode program() :{  sortNameToExpression = new HashMap < String, ASTsortExpression > ();  predicateArgumentSorts = new HashMap < String, ArrayList < String >> ();  crRuleLabels = new HashSet < String > ();  generatingSorts = new HashSet < String > ();  constantsMapping = new HashMap < String, Long > ();  warnings = new ArrayList < String > ();}{  directives(jjtThis.directives)   sortDefinitions()   predicateDeclarations()   programRules()   < EOF >  {    return jjtThis;  }}void sortDefinitions() :{}{  (    < SORTDEFKEYWORD >    (      sortDefinition()    )*  )|  {}}void sortDefinition() :{  Token t;  SimpleNode n;}{  t = < IDENTIFIER > < EQ > n = sortExpression() < DOT >  {    if (sortNameToExpression.containsKey(t.image))    {      throw new ParseException("sort " + t.image + " at line " + t.beginLine +       " column " + t.beginColumn + " was already defined");    }    for (String builtInSortName : BuiltInSorts.sortNames)    {      if (t.image.equals(builtInSortName))      {        throw new ParseException("sort " + t.image + " at line " + t.beginLine +         " column " + t.beginColumn + " is built-in and cannot be redefined");      }    }    sortNameToExpression.put(t.image, (ASTsortExpression) n);  }}SimpleNode sortExpression() :{}{  additiveSortExpression()  {    return jjtThis;  }}void additiveSortExpression() :{  jjtThis.image = "+";}{  multiplicativeSortExpression()  (    (      "+"      {        jjtThis.image += "+";      }    |       "-"      {        jjtThis.image += "-";      }    )    multiplicativeSortExpression()  )*}void multiplicativeSortExpression() :{}{  unarySortExpression()  (    < MULT > unarySortExpression()  )*}SimpleNode regularExpression() :{}{  complexRegularExpressionChoices()  {    return jjtThis;  }}void complexRegularExpressionChoices() :{}{  complexRegularExpression()  (    < OR > complexRegularExpression()  )*}void complexRegularExpression() :{}{  (    complexRegularExpressionRepeatableUnit()  )+}void complexRegularExpressionRepeatableUnit() :{}{  complexRegularExpressionUnit()  (    repeatition()  )?}void complexRegularExpressionUnit() :{  SimpleNode n;  Token t, t2;}{  n = complexRegularExpressionUnitIdentifier()  {    jjtThis.image = n.image;  }|   n = characterList()  {    jjtThis.image = n.image;  }|   t = < COMPLEMENT > complexRegularExpressionUnit()  {    jjtThis.image = t.image;  }|   t = < OP > complexRegularExpressionChoices() t2 = < CP >  {    jjtThis.image = t.image + t2.image;  }}SimpleNode complexRegularExpressionUnitIdentifier() :{  Token t, t2;}{  LOOKAHEAD(< IDENTIFIER >)  t = < IDENTIFIER >  {    jjtThis.image = t.image;    return jjtThis;  }| t2 = number()  {    jjtThis.image = t2.image;    return jjtThis;  }}void repeatition() #void :{}{  LOOKAHEAD(< OB > number() < COMMA > number() < CB >)  fromToRepeatition()| nRepeatition()}SimpleNode fromToRepeatition() #repeatition :{  Token t2;  Token from, to;}{  < OB >   from = number()   t2 = < COMMA >   to = number()   < CB >  {    jjtThis.image = from.image + t2.image + to.image;    return jjtThis;  }}SimpleNode nRepeatition() #repeatition :{  Token n;}{  < OB >   n = number()   < CB >  {    jjtThis.image = n.image;    return jjtThis;  }}SimpleNode characterList() :{  Token t1, t2;}{  LOOKAHEAD(2)  < SOB > t1 = < DIGIT > < MINUS > t2 = < DIGIT > < SCB >  {    jjtThis.image = t1.image + " " + t2.image;    return jjtThis;  }|   < SOB > t1 = < LETTER > < MINUS > t2 = < LETTER > < SCB >  {    jjtThis.image = t1.image + " " + t2.image;    return jjtThis;  }}SimpleNode condition(HashMap < String, Integer > varMap) :{  Token t, t1, t2;}{  < COLON > t1 = < OB > arithmeticTerm() t = rel()  {    jjtThis.image = t.image;  }  arithmeticTerm() t2 = < CB >  {    jjtThis.image = jjtThis.toString(varMap);    return jjtThis;  }}SimpleNode unarySortExpression() :{  Token t1, t2;  Token from, to;  HashMap < String, Integer > map;  SimpleNode c = null;}{  LOOKAHEAD(2)  t1 = < IDENTIFIER > t2 = < OP > map = specialSortExpressionList() < CP > [ c = condition(map) ]  {    if (c != null)    {      jjtThis.image = t1.image + c.toString() + t2.image;    }    else    {      jjtThis.image = t1.image + t2.image;    }    return jjtThis;  }|   LOOKAHEAD(1)  t1 = < IDENTIFIER >  {    if (!sortNameToExpression.containsKey(t1.image))    {      throw new ParseException("Sort " + t1.image       + " at line " + t1.beginLine       + ", column " + t1.beginColumn       + " was not declared");    }    jjtThis.image = t1.image;    jjtThis.beginLine = t1.beginLine;    jjtThis.beginColumn = t1.beginColumn;    return null;  }|   from = number() < DOT > < DOT > to = number()  {    jjtThis.image = from.image + " " + to.image;    return null;  }|   t1 = < DOLLAR > regularExpression()  {    jjtThis.image = t1.image;    return null;  }|   t1 = < OP > sortExpression() t2 = < CP >  {    jjtThis.image = t1.image + t2.image;    return null;  }}void simpleSortExpression() #sortExpression :{}{  simpleAdditiveSortExpression()}void simpleAdditiveSortExpression() #additiveSortExpression :{  jjtThis.image = "+";}{  simpleMultiplicativeSortExpression()}void simpleMultiplicativeSortExpression() #multiplicativeSortExpression :{}{  simpleUnarySortExpression()}void simpleUnarySortExpression() #unarySortExpression :{  Token t1;}{  t1 = < IDENTIFIER >  {    if (!sortNameToExpression.containsKey(t1.image))    {      throw new ParseException("Sort " + t1.image       + " at line " + t1.beginLine       + ", column " + t1.beginColumn       + " was not declared");    }    jjtThis.image = t1.image;    jjtThis.beginLine = t1.beginLine;    jjtThis.beginColumn = t1.beginColumn;  }}Token specialSortExpression() #void :{  Token t;}{  LOOKAHEAD(< IDENTIFIER > < OP > < VARIABLE > < CP >)  simpleSortExpression() < OP > t = < VARIABLE > < CP >  {    return t;  }| sortExpression()  {    return null;  }}HashMap < String, Integer > specialSortExpressionList() #sortExpressionList :{  HashMap < String, Integer > variableMapping   = new HashMap < String, Integer > ();  int agr = 0;  Token t;}{  t = specialSortExpression()  {    if (t != null)    {      variableMapping.put(t.image, agr);    }    agr++;  }  (    < COMMA > t = specialSortExpression()    {      if (t != null)      {        variableMapping.put(t.image, agr);      }      agr++;    }  )*  {    return variableMapping;  }}Token number() #void :{  Token t;}{  t = < POSITIVE_INTEGER >  {    return t;  }| t = < ZERO >  {    return t;  }| t = < NONZERODIGIT >  {    return t;  }|   t = < IDENTIFIER >  {    if (!constantsMapping.containsKey(t.image))    {      throw new       ParseException("ERROR: Constant \"" + t.image + "\" at line " + t.beginLine + ", column" + t.beginColumn +       " was not defined");      //return t;
    }    else    {      t.image = constantsMapping.get(t.image).toString();      return t;    }  }}void predicateDeclarations() :{}{  < PREDDEFKEYWORD >  (    predicateDeclaration()  )*  {    for (String sortName : sortNameToExpression.keySet())    {      if (predicateArgumentSorts.containsKey(sortName))      {        throw new         ParseException("ERROR: Sort name \"" + sortName + "\" is also a name of one of declared predicates");      }      predicateArgumentSorts.put(sortName, new ArrayList < String > ());      predicateArgumentSorts.get(sortName).add(sortName);    }  }}void predicateDeclaration() :{  Token t;  ArrayList < String > arguments = new ArrayList < String > ();}{  t = < IDENTIFIER >  {    if (predicateArgumentSorts.containsKey(t.image))    {      throw new ParseException("Line " + t.beginLine + ": " + "predicate " + t.image + " was already declared");    }  }  < OP >  (    arguments = identifierList()  )?  {
    predicateArgumentSorts.put(t.image, arguments);  }  < CP > < DOT >}ArrayList < String > identifierList() :{  ArrayList < String > result = new ArrayList < String > ();  Token t;}{  t = < IDENTIFIER >  {
     if(!sortNameToExpression.containsKey(t.image))
       {
        throw new ParseException("Line " + t.beginLine + ", column "+t.beginColumn+": " + "sort \"" + t.image + "\" was not defined");
       }   
        result.add(t.image);  }  (    < COMMA > t = < IDENTIFIER >    {      result.add(t.image);    }  )*  {    return result;  }}SimpleNode programRules() :{}{  < PROGRULDEFKEYWORD >  (    programRule()  )*  {    return jjtThis;  }}SimpleNode programRule() :{  Token t;  SimpleNode n;}{  LOOKAHEAD(2)  t = label()  {    jjtThis.beginLine = t.beginLine;    jjtThis.beginColumn = t.beginColumn;    jjtThis.setLabel(t.image);    if (crRuleLabels.contains(t.image))    {      throw new ParseException("cr-rule label " + t.image + " at line " + t.beginLine +       " column " + t.beginColumn + " occures more then once");    }    else    {      crRuleLabels.add(t.image);    }  }  n = unlabeledProgramCrRule()  {    jjtThis.beginLine = n.beginLine;    jjtThis.beginColumn = n.beginColumn;    return jjtThis;  }|   n = unlabeledProgramRule()  {    jjtThis.beginLine = n.beginLine;    jjtThis.beginColumn = n.beginColumn;    return jjtThis;  }}SimpleNode unlabeledProgramRule() :{  SimpleNode n;  Token from, to, sep;}{  LOOKAHEAD(predSymbol() number() < DOT >)  n = predSymbol() from = number() < DOT > < DOT > to = number() < CP > < DOT > //can be body here after safety fix!
  {    jjtThis.beginLine = n.beginLine;    jjtThis.beginColumn = n.beginColumn;    jjtThis.image = n.image + " " + from.image + " " + to.image;    return jjtThis;  }|   n = head() sep = exBody()  {    jjtThis.image = sep.image;    jjtThis.beginLine = n.beginLine;    jjtThis.beginColumn = n.beginColumn;    return jjtThis;  }|   sep = < ORRSEP >  {    jjtThis.image = sep.image;    jjtThis.beginLine = sep.beginLine;    jjtThis.beginColumn = sep.beginColumn;  }  body() < DOT >  {    return jjtThis;  }|   sep = < CRRSEP >  {    jjtThis.beginLine = sep.beginLine;    jjtThis.beginColumn = sep.beginColumn;    jjtThis.image = sep.image;  }  body() < DOT >  {    return jjtThis;  }|   sep = < WEAKSEP >  {    jjtThis.beginLine = sep.beginLine;    jjtThis.beginColumn = sep.beginColumn;    jjtThis.image = sep.image;  }  body() < DOT > [ constraintParams() ]  {    return jjtThis;  }}void constraintParams() :{  Token t0;  Token t1 = null, t2 = null, t3 = null, t4 = null, t5 = null;  jjtThis.image = "";}{  t0 = < PARAM_BEGIN >  [    (      t1 = var()    | t2 = number()    )  ]  t5 = < COLON >  [    (      t3 = var()    | t4 = number()    )  ]  < PARAM_END >  {    if (t1 == null && t2 == null && t3 == null && t4 == null)    {      throw new ParseException("line " + t0.beginLine + ", column " + t0.beginColumn +       ": weak constraint paramethers cannot both be empty");    }    if (t2 != null)    {      jjtThis.image += t2.image;    }    else if (t1 != null)    {      jjtThis.image += "V";    }    jjtThis.image += t5.image;    if (t4 != null)    {      jjtThis.image += t4.image;    }    else if (t3 != null)    {      jjtThis.image += "V";    }  }}SimpleNode unlabeledProgramCrRule() :{  SimpleNode n;  Token t;}{  n = head() t = exCrBody()  {    jjtThis.beginLine = n.beginLine;    jjtThis.beginColumn = n.beginColumn;    jjtThis.image = t.image;    return jjtThis;  }|   t = < CRRSEP > body() < DOT >  {    jjtThis.beginLine = t.beginLine;    jjtThis.beginColumn = t.beginColumn;    jjtThis.image = t.image;    return jjtThis;  }}Token label() #void :{  Token t;}{  t = < IDENTIFIER >   < COLON >  {    return t;  }}Token exBody() #void :{  Token t;}{  t = exStandartBody()  {    return t;  }|   t = exCrBody()  {    return t;  }}Token exStandartBody() #void :{  Token t;}{  t = < ORRSEP > body() < DOT >  {    return t;  }|   t = < DOT >  {    return new Token(SparcTranslatorConstants.ORRSEP, ":-");  }}Token exCrBody() #void :{  Token t;}{  t = < CRRSEP > crBodyWithoutSep()  {    return t;  }}void crBodyWithoutSep() #void :{}{  < DOT >|   body() < DOT >}SimpleNode head() :{  SimpleNode n;}{  LOOKAHEAD(2)  n = choice_rule()  {    jjtThis.beginLine = n.beginLine;    jjtThis.beginColumn = n.beginColumn;    return jjtThis;  }|   n = disjunction()  {    jjtThis.beginLine = n.beginLine;    jjtThis.beginColumn = n.beginColumn;    return jjtThis;  }}SimpleNode disjunction() :{  SimpleNode n;}{  n = nonRelAtom()  {    jjtThis.beginLine = n.beginLine;    jjtThis.beginColumn = n.beginColumn;  }  (    < OR > nonRelAtom()  )*  {    return jjtThis;  }}SimpleNode choice_rule() :{  SimpleNode n1 = null;  Token t;}{  [    n1 = arithmeticTerm() [ rel() ]  ]  t = < OB > choice_elements()   < CB >  [    [ rel() ] arithmeticTerm()  ]  {    if (n1 != null)    {      jjtThis.beginLine = n1.beginLine;      jjtThis.beginColumn = n1.beginColumn;    }    else    {      jjtThis.beginLine = t.beginLine;      jjtThis.beginColumn = t.beginColumn;    }    throw new ParseException("line " + jjtThis.beginLine + ", column " + jjtThis.beginColumn +     ": choice rules are not supported");  }}void choice_elements() :{}{  choice_element()  (    < SEMICOLON > choice_element()  )*}void choice_element() :{  SimpleNode n;}{  n = nonRelAtom() [ < COLON > extendedSimpleAtomList() ]  {    jjtThis.beginLine = n.beginLine;    jjtThis.beginColumn = n.beginColumn;  }}void extendedSimpleAtomList() :{}{  simpleAtom()  (    < COMMA > simpleAtom()  )*}void body() :{}{  atom()  (    < COMMA > atom()  )*}Token var() :{  Token t;}{  t = < VARIABLE >  {    jjtThis.image = t.image;
    jjtThis.setOriginalImage(t.image);    return t;  }}SimpleNode nonRelAtom() :{  SimpleNode n;}{  n = predSymbol()  {    jjtThis.beginLine = n.beginLine;    jjtThis.beginColumn = n.beginColumn;  }  [ termList() < CP > ]  {    return jjtThis;  }}void simpleAtom() :{  SimpleNode n;}{  LOOKAHEAD(symbolicTerm() rel() symbolicTerm())  symbolicTerm() rel() symbolicTerm()|   LOOKAHEAD(symbolicTerm() rel() var())  symbolicTerm() rel() var()|   LOOKAHEAD(arithmeticTerm() rel() arithmeticTerm())  arithmeticTerm() rel() arithmeticTerm()|   LOOKAHEAD(var() rel() symbolicTerm())  var() rel() symbolicTerm()|   LOOKAHEAD(arithmeticTerm() eqrel() symbolicTerm())  arithmeticTerm() eqrel() symbolicTerm()|   LOOKAHEAD(symbolicTerm() eqrel() arithmeticTerm())  symbolicTerm() eqrel() arithmeticTerm()|   n = extendedNonRelAtom()  {    jjtThis.image = n.image;  }}SimpleNode extendedNonRelAtom() :{  Token t;  jjtThis.image = "";}{  [    t = < NOT >    {      jjtThis.image = t.image;    }  ]  predSymbol() [ termList() < CP > ]  {    return jjtThis;  }}SimpleNode addOp() #void :{  Token t;  SimpleNode n = new SimpleNode(0);}{  t = < PLUS >  {    n.image = t.image;    return n;  }|   t = < MINUS >  {    n.image = t.image;    return n;  }}SimpleNode multOp() #void :{  Token t;  SimpleNode n = new SimpleNode(0);}{  t = < MULT >  {    n.image = t.image;    return n;  }|   t = < MOD >  {    n.image = t.image;    return n;  }|   t = < DIV >  {    n.image = t.image;    return n;  }}SimpleNode arithmeticTerm() :{  SimpleNode n;}{  n = additiveArithmeticTerm()  {    jjtThis.beginLine = n.beginLine;    jjtThis.beginColumn = n.beginColumn;    return jjtThis;  }}SimpleNode atomicArithmeticTerm() :{  Token t;}{  t = number()  {    jjtThis.image = t.image;    jjtThis.beginLine = t.beginLine;    jjtThis.beginColumn = t.beginColumn;    return jjtThis;  }|   t = var()  {    jjtThis.image = t.image;    jjtThis.beginLine = t.beginLine;    jjtThis.beginColumn = t.beginColumn;    return jjtThis;  }|   t = < OP > arithmeticTerm() < CP >  {    jjtThis.image = t.image;    jjtThis.beginLine = t.beginLine;    jjtThis.beginColumn = t.beginColumn;    return jjtThis;  }}SimpleNode additiveArithmeticTerm() :{  SimpleNode n;  jjtThis.image = "+";}{  n = multiplicativeArithmeticTerm()  {    jjtThis.beginLine = n.beginLine;    jjtThis.beginColumn = n.beginColumn;  }  (    n = addOp()    {      jjtThis.image += n.image;    }    multiplicativeArithmeticTerm()  )*  {    return jjtThis;  }}SimpleNode multiplicativeArithmeticTerm() :{  SimpleNode n;  jjtThis.image = "";}{  n = atomicArithmeticTerm()  {    jjtThis.beginLine = n.beginLine;    jjtThis.beginColumn = n.beginColumn;  }  (    n = multOp()    {      jjtThis.image += n.image;    }    atomicArithmeticTerm()  )*  {    return jjtThis;  }}SimpleNode symbolicFunction() :{  Token t;}{  t = < IDENTIFIER_WITH_OP >  {    jjtThis.image = t.image;    jjtThis.beginColumn = t.beginColumn;    jjtThis.beginLine = t.beginLine;    return jjtThis;  }}SimpleNode symbolicConstant() :{  Token t;}{  t = < IDENTIFIER >  {    jjtThis.image = t.image;    jjtThis.beginLine = t.beginLine;    jjtThis.beginColumn = t.beginColumn;    return jjtThis;  }}SimpleNode symbolicTerm() :{  SimpleNode n;}{  n = symbolicConstant()  {    jjtThis.beginLine = n.beginLine;    jjtThis.beginColumn = n.beginColumn;    return jjtThis;  }|   n = symbolicFunction()  {    jjtThis.beginLine = n.beginLine;    jjtThis.beginColumn = n.beginColumn;  }  termList() < CP >  {    return jjtThis;  }}SimpleNode term() :{  SimpleNode n;  Token t;  jjtThis.image = "";}{  LOOKAHEAD(symbolicTerm())  n = symbolicTerm()  {    jjtThis.beginLine = n.beginLine;    jjtThis.beginColumn = n.beginColumn;
    return jjtThis;  }| LOOKAHEAD(var() (< CP >| < COMMA >))  t = var()  {    //System.out.println("t.image");
    jjtThis.image = t.image;    jjtThis.beginLine = t.beginLine;    jjtThis.beginColumn = t.beginColumn;
    return jjtThis;  }| n = arithmeticTerm()  {    jjtThis.beginLine = n.beginLine;    jjtThis.beginColumn = n.beginColumn;
    return jjtThis;  }}void termList() :{}{  term()  (    < COMMA > term()  )*}Token rel() #void :{  Token t;}{  t = < EQ >  {    return t;  }| t = < NOTEQ >  {    return t;  }| t = < GT >  {    return t;  }| t = < GTEQ >  {    return t;  }| t = < SM >  {    return t;  }| t = < SMEQ >  {    return t;  }}Token eqrel() #void :{  Token t;}{  t = < EQ >  {    return t;  }| t = < NOTEQ >  {    return t;  }}SimpleNode predSymbol() :{  Token t;}{  t = < IDENTIFIER >  {    jjtThis.image = t.image;    jjtThis.beginLine = t.beginLine;    jjtThis.beginColumn = t.beginColumn;    return jjtThis;  }|   t = < IDENTIFIER_WITH_OP >  {    jjtThis.image = t.image.substring(0, t.image.length() - 1);    if (sortNameToExpression.containsKey(jjtThis.image))    {      generatingSorts.add(jjtThis.image);    }    jjtThis.beginLine = t.beginLine;    jjtThis.beginColumn = t.beginColumn;    return jjtThis;  }| t = < NEGATIVE_ATOM_WITH_OP >  {    jjtThis.negative = true;    jjtThis.image = t.image.substring(1, t.image.length() - 1);    jjtThis.beginLine = t.beginLine;    jjtThis.beginColumn = t.beginColumn;    return jjtThis;  }}void atom() :{  Token t1;}{  LOOKAHEAD([ arithmeticTerm() rel() ] aggregateFunction())  aggregate()|   LOOKAHEAD(symbolicTerm() rel() symbolicTerm())  symbolicTerm() t1 = rel() symbolicTerm()  {    jjtThis.image = t1.image;  }|   LOOKAHEAD(symbolicTerm() rel() var())  symbolicTerm() t1 = rel() var()  {    jjtThis.image = t1.image;  }|   LOOKAHEAD(var() rel() symbolicTerm())  var() t1 = rel() symbolicTerm()  {    jjtThis.image = t1.image;  }|   LOOKAHEAD(arithmeticTerm() eqrel() symbolicTerm())  arithmeticTerm() t1 = eqrel() symbolicTerm()  {    jjtThis.image = t1.image;  }|   LOOKAHEAD(symbolicTerm() eqrel() arithmeticTerm())  symbolicTerm() t1 = eqrel() arithmeticTerm()  {    jjtThis.image = t1.image;  }|   LOOKAHEAD(arithmeticTerm() rel() arithmeticTerm())  arithmeticTerm() t1 = rel() arithmeticTerm()  {    jjtThis.image = t1.image;  }|   extendedNonRelAtom()}void aggregate() :{  Token t1 = null, t2 = null;  jjtThis.image = "";}{  [ arithmeticTerm() t1 = rel() ] aggregateFunction()   < OB > aggregateElements()   < CB > [ t2 = rel() arithmeticTerm() ]  {    if (t1 != null)    {      jjtThis.image += "L" + t1.image;    }    if (t2 != null)    {      jjtThis.image += "R" + t2.image;    }  }}void aggregateElements() :{}{  aggregateElement()  (    < SEMICOLON > aggregateElement()  )*}void aggregateElement() :{  SimpleNode n;}{  (    LOOKAHEAD(2)    n = nonRelAtom()  | n = arithmeticTerm()  )  (    < COMMA >    (      LOOKAHEAD(2)      nonRelAtom()    | arithmeticTerm()    )  )*  [ < COLON > extendedSimpleAtomList() ]  {    jjtThis.beginLine = n.beginLine;    jjtThis.beginColumn = n.beginColumn;  }}void aggregateFunction() :{  Token t;}{  t = < AGGREGATE_COUNT >  {    jjtThis.image = t.image;  }|   t = < AGGREGATE_MAX >  {    jjtThis.image = t.image;  }|   t = < AGGREGATE_MIN >  {    jjtThis.image = t.image;  }|   t = < AGGREGATE_SUM >  {    jjtThis.image = t.image;  }}void atomSequence() :{}{  atom()  (    < COMMA > atom()  )*}void characterRegularExpression() :{}{  {}}void directives(ArrayList < String > directives) #void :{}{  (    directive(directives)  )*  {    addBuiltInSorts();  }}void directive(ArrayList < String > directives) #void :{  Token t, t1, t2, t3, t4;}{  t = < MAXINTDIRECTIVE > t1 = < EQ > t2 = number() t3 = < DOT >  {    BuiltInSorts.setMaxInt(Integer.parseInt(t2.image));    directives.add(t.image + t1.image + t2.image + t3.image);  }|   t = < CONSTDIRECTIVE > t1 = < IDENTIFIER > t2 = < EQ > t3 = number() t4 = < DOT >  {    directives.add(t.image + " " + t1.image + t2.image + t3.image + t4.image);    constantsMapping.put(t1.image, Long.parseLong(t3.image));  }}
