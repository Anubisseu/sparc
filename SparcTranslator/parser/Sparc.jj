/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. Sparc.jj */
/*@egen*///TODO: change extendedNonRelAtom to extendedAtom.
options{  BUILD_PARSER = true;  STATIC = false;  OUTPUT_DIRECTORY = "/home/iensen/SparcT/sparc/src/parser";                                }PARSER_BEGIN(SparcTranslator)package parser;import java.io.*;import sorts.*;import java.util.HashMap;import java.util.ArrayList;import java.util.HashSet;import java.util.Scanner;import translating.Translator;import typechecking.TypeChecker;
import translating.InstanceGenerator;@ SuppressWarnings("all") public class SparcTranslator/*@bgen(jjtree)*/implements SparcTranslatorTreeConstants/*@egen*/{/*@bgen(jjtree)*/
  protected JJTSparcTranslatorState jjtree = new JJTSparcTranslatorState();

/*@egen*/  // mapping from sort names to sort expressions assigned to the sorts
  public HashMap < String, ASTsortExpression > sortNameToExpression;  // mapping from predicate names to a list of names of sorts describing
  // arguments
  public HashMap < String, ArrayList < String >> predicateArgumentSorts;  // labels of cr-rules
  public HashSet < String > crRuleLabels;    //sort occurred explicitly in the program
  public HashSet < String > generatingSorts;  // mapping from constant names to their values.
  public HashMap < String, Long > constantsMapping;  // warnings found during the translation
  private ArrayList < String > warnings;  public static void main(String [] args)  {    int argc = args.length;    System.err.println("SPARC to DLV translator V2.10");    ArrayList < String > inputFiles = new ArrayList < String > ();    Reader sr = null;    Writer out = null;    // check for inappropriate arguments
    if (argc == 1 && (args [0].equals("-h") || args [0].equals("-help")     || args [0].equals("-H") || args [0].equals("-Help")))    {      show_usage();      return;    }    /* if first argument is provided and
       it is not -h -help -H -Help - it is the first input file*/    /* We read input files until we get -o or the end of args array*/    int currentArgIndex = 0;    // add input files
    while (currentArgIndex < args.length && !args [currentArgIndex].startsWith("-"))    {      inputFiles.add(args [currentArgIndex]);      ++currentArgIndex;    }    if (currentArgIndex < args.length && args [currentArgIndex].startsWith("-"))    {      /// name of output file should follow -o option
      if (!args [currentArgIndex].equals("-o") || currentArgIndex + 1 == args.length)      {        show_usage();        return;      }      ++currentArgIndex;      // check for existence
      if (new File(args [currentArgIndex]).exists() && !new File(args [currentArgIndex]).isDirectory())      {        System.err.println("the output file already exists , do you want to overwrite it? y/n:");        char rep;        try        {          rep = (char) System.in.read();        }        catch (IOException e)        {          e.printStackTrace();          return;        }        if (rep != 'y' && rep != 'Y')        {          return;        }      }      try      {        out = new FileWriter(args [currentArgIndex]);      }      catch (IOException e)      {        e.printStackTrace();      }    }    if (sr == null) sr = new InputStreamReader(System.in);    if (out == null) out = new OutputStreamWriter(System.out);    ;    try    {      int currentInputFileIndex = 0;      if (inputFiles.size() != 0)      {
        // read input from multiple files        try        {          sr = new FileReader(inputFiles.get(currentInputFileIndex));          ++currentInputFileIndex;        }        catch (FileNotFoundException fileException)        {          System.err.println("%INPUT FILE ERROR: " + fileException.getMessage());          return;        }      }      SparcTranslator p = new SparcTranslator(sr);      SimpleNode e = p.program();
      //process regular expression      RIdentifierSplitVisitor v = new RIdentifierSplitVisitor();      e.jjtAccept(v, null);      RRepeatitionRemover removeNMrepeatitions = new RRepeatitionRemover();      e.jjtAccept(removeNMrepeatitions, null);      RChoiceRemover choiceremover = new RChoiceRemover();      e.jjtAccept(choiceremover, null);
      InstanceGenerator gen = new InstanceGenerator(p.predicateArgumentSorts,
				p.sortNameToExpression);      TypeChecker tc = new TypeChecker(p.sortNameToExpression, p.predicateArgumentSorts, p.constantsMapping,gen);      Translator tr = new Translator(out, p,gen);
      // do typechecking of rules in the first file
      if (inputFiles.size() != 0)
      {
        tr.setInputFileName(getShortFileName(inputFiles.get(0)));
        tc.setInputFileName(getShortFileName(inputFiles.get(0)));
      }      tc.checkRules((ASTprogramRules) e.jjtGetChild(2));    
      // translate program in the first file      tr.translateProgram((ASTprogram) e, p.generatingSorts, (inputFiles.size() > 1) ? false : true);
      //process other files      for (int fileIndex = 1; fileIndex < inputFiles.size(); fileIndex++)      {        try        {          sr = new FileReader(inputFiles.get(fileIndex));        }        catch (FileNotFoundException fileException)        {          System.err.println("%INPUT FILE ERROR: " + fileException.getMessage());          ;          return;        }        p.ReInit(sr);        tr.setInputFileName(getShortFileName(inputFiles.get(fileIndex)));        tc.setInputFileName(getShortFileName(inputFiles.get(fileIndex)));        SimpleNode rules = p.programRules();
        //do typechecking of rules from other files        tc.checkRules((ASTprogramRules) rules);        /* we only write warnings after we translated the last file:*/        tr.translateAndWriteRules((ASTprogramRules) rules, fileIndex == inputFiles.size() - 1);      }    }    catch (ParseException pe)    {      System.err.println(pe.getMessage());      ;      return;    }    System.err.println("program translated");  }
  /**
  * @return file name without full path.
  */  private static String getShortFileName(String fullPath)  {    File file = new File(fullPath);    return file.getName();  }  /**
  * Output help message
  */  private static void show_usage()  {    System.err.println("usage0(reads from console and outputs to console): sparc");    System.err.println("usage1(reads from file and outputs to console): sparc input_file_1,...,input_file_n");    System.err.println("usage2(reads from file and outputs to file): sparc input_file_1,...,input_file_n -o output_file");  }  /**
  * Add built-in sorts to sort expressions
  */  public void addBuiltInSorts()  {    HashMap < String, ASTsortExpression > builtInSorts = BuiltInSorts.getBuiltInSorts();    for (String sortName : builtInSorts.keySet())    {      sortNameToExpression.put(sortName, builtInSorts.get(sortName));    }  }  /**
  * Add warning to set of warnings
  */  public void addWarning(String warning)  {    warnings.add(warning);  }  public ArrayList < String > getWarnings()  {    return warnings;  }}PARSER_END(SparcTranslator)< DEFAULT, IN_PROGRAM_RULES >TOKEN :{  < MAXINTDIRECTIVE : "#maxint" >|   < CONSTDIRECTIVE : "#const" >|   < SORTDEFKEYWORD : "sort" ([ "\r", "\n", "\t", " " ])+ "definitions" ([ "\r", "\t", " ", "\n" ])+ >|   < PREDDEFKEYWORD : "predicate" ([ "\r", "\n", "\t", " " ])+ "declarations" ([ "\r", "\t", " ", "\n" ])+ >|   < PROGRULDEFKEYWORD :     "program" ([ "\r", "\n", "\t", " " ])+ "rules" ([ "\r", "\t", " ", "\n" ])+ > : IN_PROGRAM_RULES|   < NOT : "not" ([ "\t", "\r", " " ])+ >|   < MOD : "mod" >|   < IDENTIFIER : [ "a"-"z" ] ([ "a"-"z", "A"-"Z", "0"-"9", "_" ])* >|   < VARIABLE :    (      [ "A"-"Z" ] ([ "a"-"z", "A"-"Z", "0"-"9", "_" ])*    | "_"    ) >|   < NONZERODIGIT : [ "1"-"9" ] >|   < POSITIVE_INTEGER :    < NONZERODIGIT >    (      < ZERO >    | < NONZERODIGIT >    )* >|   < ZERO : "0" >|   < PLUS : "+" >|   < MULT : "*" >|   < DIV : "/" >|   < EQ : "=" >|   < NOTEQ : "!=" >|   < GT : ">" >|   < GTEQ : ">=" >|   < SM : "<" >|   < SMEQ : "<=" >|   < OP : "(" >|   < CP : ")" >|   < OB : "{" >|   < CB : "}" >|   < ORRSEP : ":-" >|   < CRRSEP : ":+" >|   < WEAKSEP : ":~" >|   < COMMA : "," >|   < DOT : "." >|   < COLON : ":" >|   < SEMICOLON : ";" >|   < DOLLAR : "$" >|   < COMPLEMENT : "~" >|   < OR : "|" >|   < AGGREGATE_COUNT : "#count" >|   < AGGREGATE_SUM : "#sum" >|   < AGGREGATE_MIN : "#min" >|   < AGGREGATE_MAX : "#max" >}< DEFAULT >TOKEN :{  < SOB : "[" > : IN_REGULAREXPRESSIONSEQUENCE}< IN_REGULAREXPRESSIONSEQUENCE >TOKEN :{  < LETTER :    (      [ "A"-"Z" ]    | [ "a"-"z" ]    ) >|   < DIGIT : ([ "0"-"9" ]) >|   < SCB : "]" > : DEFAULT}< IN_PROGRAM_RULES >TOKEN :{  < IDENTIFIER_WITH_OP : [ "a"-"z" ] ([ "a"-"z", "A"-"Z", "0"-"9", "_" ])* ([ "\t", "\r", "\n" ])* "(" >|   < NEGATIVE_ATOM_WITH_OP : "-" [ "a"-"z" ] ([ "a"-"z", "A"-"Z", "0"-"9", "_" ])* ([ "\t", "\r", "\n" ])* "(" >|   < PARAM_END : "]" >|   < PARAM_BEGIN : "[" >}< DEFAULT, IN_PROGRAM_RULES, IN_REGULAREXPRESSIONSEQUENCE >SKIP :{  < SINGLE_LINE_COMMENT :    "%" (~[ "\n", "\r" ])*    (      "\r"    | "\n"    | "\r\n"    )? >|   < SPACE : ([ "\n", "\r", "\t", " " ])+ >}< DEFAULT, IN_PROGRAM_RULES, IN_REGULAREXPRESSIONSEQUENCE >TOKEN :{  < MINUS : "-" >}SimpleNode program() :{/*@bgen(jjtree) program */
  ASTprogram jjtn000 = new ASTprogram(JJTPROGRAM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  sortNameToExpression = new HashMap < String, ASTsortExpression > ();  predicateArgumentSorts = new HashMap < String, ArrayList < String >> ();  crRuleLabels = new HashSet < String > ();  generatingSorts = new HashSet < String > ();  constantsMapping = new HashMap < String, Long > ();  warnings = new ArrayList < String > ();}{/*@bgen(jjtree) program */
  try {
/*@egen*/  directives(jjtn000.directives)   sortDefinitions()   predicateDeclarations()   programRules()   < EOF >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    return jjtn000;  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}void sortDefinitions() :{/*@bgen(jjtree) sortDefinitions */
  ASTsortDefinitions jjtn000 = new ASTsortDefinitions(JJTSORTDEFINITIONS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) sortDefinitions */
  try {
/*@egen*/  (    < SORTDEFKEYWORD >    (      sortDefinition()    )*  )|/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {}/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}void sortDefinition() :{/*@bgen(jjtree) sortDefinition */
  ASTsortDefinition jjtn000 = new ASTsortDefinition(JJTSORTDEFINITION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  Token t;  SimpleNode n;}{/*@bgen(jjtree) sortDefinition */
  try {
/*@egen*/  t = < IDENTIFIER > < EQ > n = sortExpression() < DOT >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    if (sortNameToExpression.containsKey(t.image))    {      throw new ParseException("sort " + t.image + " at line " + t.beginLine +       " column " + t.beginColumn + " was already defined");    }    for (String builtInSortName : BuiltInSorts.sortNames)    {      if (t.image.equals(builtInSortName))      {        throw new ParseException("sort " + t.image + " at line " + t.beginLine +         " column " + t.beginColumn + " is built-in and cannot be redefined");      }    }    sortNameToExpression.put(t.image, (ASTsortExpression) n);  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}SimpleNode sortExpression() :{/*@bgen(jjtree) sortExpression */
  ASTsortExpression jjtn000 = new ASTsortExpression(JJTSORTEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) sortExpression */
  try {
/*@egen*/  additiveSortExpression()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    return jjtn000;  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}void additiveSortExpression() :{/*@bgen(jjtree) additiveSortExpression */
  ASTadditiveSortExpression jjtn000 = new ASTadditiveSortExpression(JJTADDITIVESORTEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  jjtn000.image = "+";}{/*@bgen(jjtree) additiveSortExpression */
  try {
/*@egen*/  multiplicativeSortExpression()  (    (      "+"      {        jjtn000.image += "+";      }    |       "-"      {        jjtn000.image += "-";      }    )    multiplicativeSortExpression()  )*/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}void multiplicativeSortExpression() :{/*@bgen(jjtree) multiplicativeSortExpression */
  ASTmultiplicativeSortExpression jjtn000 = new ASTmultiplicativeSortExpression(JJTMULTIPLICATIVESORTEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) multiplicativeSortExpression */
  try {
/*@egen*/  unarySortExpression()  (    < MULT > unarySortExpression()  )*/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}SimpleNode regularExpression() :{/*@bgen(jjtree) regularExpression */
  ASTregularExpression jjtn000 = new ASTregularExpression(JJTREGULAREXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) regularExpression */
  try {
/*@egen*/  complexRegularExpressionChoices()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    return jjtn000;  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}void complexRegularExpressionChoices() :{/*@bgen(jjtree) complexRegularExpressionChoices */
  ASTcomplexRegularExpressionChoices jjtn000 = new ASTcomplexRegularExpressionChoices(JJTCOMPLEXREGULAREXPRESSIONCHOICES);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) complexRegularExpressionChoices */
  try {
/*@egen*/  complexRegularExpression()  (    < OR > complexRegularExpression()  )*/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}void complexRegularExpression() :{/*@bgen(jjtree) complexRegularExpression */
  ASTcomplexRegularExpression jjtn000 = new ASTcomplexRegularExpression(JJTCOMPLEXREGULAREXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) complexRegularExpression */
  try {
/*@egen*/  (    complexRegularExpressionRepeatableUnit()  )+/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}void complexRegularExpressionRepeatableUnit() :{/*@bgen(jjtree) complexRegularExpressionRepeatableUnit */
  ASTcomplexRegularExpressionRepeatableUnit jjtn000 = new ASTcomplexRegularExpressionRepeatableUnit(JJTCOMPLEXREGULAREXPRESSIONREPEATABLEUNIT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) complexRegularExpressionRepeatableUnit */
  try {
/*@egen*/  complexRegularExpressionUnit()  (    repeatition()  )?/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}void complexRegularExpressionUnit() :{/*@bgen(jjtree) complexRegularExpressionUnit */
  ASTcomplexRegularExpressionUnit jjtn000 = new ASTcomplexRegularExpressionUnit(JJTCOMPLEXREGULAREXPRESSIONUNIT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  SimpleNode n;  Token t, t2;}{/*@bgen(jjtree) complexRegularExpressionUnit */
  try {
/*@egen*/  n = complexRegularExpressionUnitIdentifier()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    jjtn000.image = n.image;  }|   n = characterList()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    jjtn000.image = n.image;  }|   t = < COMPLEMENT > complexRegularExpressionUnit()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    jjtn000.image = t.image;  }|   t = < OP > complexRegularExpressionChoices() t2 = < CP >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    jjtn000.image = t.image + t2.image;  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}SimpleNode complexRegularExpressionUnitIdentifier() :{/*@bgen(jjtree) complexRegularExpressionUnitIdentifier */
  ASTcomplexRegularExpressionUnitIdentifier jjtn000 = new ASTcomplexRegularExpressionUnitIdentifier(JJTCOMPLEXREGULAREXPRESSIONUNITIDENTIFIER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  Token t, t2;}{/*@bgen(jjtree) complexRegularExpressionUnitIdentifier */
  try {
/*@egen*/  LOOKAHEAD(< IDENTIFIER >)  t = < IDENTIFIER >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    jjtn000.image = t.image;    return jjtn000;  }| t2 = number()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    jjtn000.image = t2.image;    return jjtn000;  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}void repeatition()       :{}{  LOOKAHEAD(< OB > number() < COMMA > number() < CB >)  fromToRepeatition()| nRepeatition()}SimpleNode fromToRepeatition()              :{/*@bgen(jjtree) repeatition */
  ASTrepeatition jjtn000 = new ASTrepeatition(JJTREPEATITION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  Token t2;  Token from, to;}{/*@bgen(jjtree) repeatition */
  try {
/*@egen*/  < OB >   from = number()   t2 = < COMMA >   to = number()   < CB >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    jjtn000.image = from.image + t2.image + to.image;    return jjtn000;  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}SimpleNode nRepeatition()              :{/*@bgen(jjtree) repeatition */
  ASTrepeatition jjtn000 = new ASTrepeatition(JJTREPEATITION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  Token n;}{/*@bgen(jjtree) repeatition */
  try {
/*@egen*/  < OB >   n = number()   < CB >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    jjtn000.image = n.image;    return jjtn000;  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}SimpleNode characterList() :{/*@bgen(jjtree) characterList */
  ASTcharacterList jjtn000 = new ASTcharacterList(JJTCHARACTERLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  Token t1, t2;}{/*@bgen(jjtree) characterList */
  try {
/*@egen*/  LOOKAHEAD(2)  < SOB > t1 = < DIGIT > < MINUS > t2 = < DIGIT > < SCB >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    jjtn000.image = t1.image + " " + t2.image;    return jjtn000;  }|   < SOB > t1 = < LETTER > < MINUS > t2 = < LETTER > < SCB >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    jjtn000.image = t1.image + " " + t2.image;    return jjtn000;  }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}SimpleNode condition(HashMap < String, Integer > varMap) :{/*@bgen(jjtree) condition */
  ASTcondition jjtn000 = new ASTcondition(JJTCONDITION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  Token t, t1, t2;}{/*@bgen(jjtree) condition */
  try {
/*@egen*/  < COLON > t1 = < OB > arithmeticTerm() t = rel()  {    jjtn000.image = t.image;  }  arithmeticTerm() t2 = < CB >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    jjtn000.image = jjtn000.toString(varMap);    return jjtn000;  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}SimpleNode unarySortExpression() :{/*@bgen(jjtree) unarySortExpression */
  ASTunarySortExpression jjtn000 = new ASTunarySortExpression(JJTUNARYSORTEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  Token t1, t2;  Token from, to;  HashMap < String, Integer > map;  SimpleNode c = null;}{/*@bgen(jjtree) unarySortExpression */
  try {
/*@egen*/  LOOKAHEAD(2)  t1 = < IDENTIFIER > t2 = < OP > map = specialSortExpressionList() < CP > [ c = condition(map) ]/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    if (c != null)    {      jjtn000.image = t1.image + c.toString() + t2.image;    }    else    {      jjtn000.image = t1.image + t2.image;    }    return jjtn000;  }|   LOOKAHEAD(1)  t1 = < IDENTIFIER >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    if (!sortNameToExpression.containsKey(t1.image))    {      throw new ParseException("Sort " + t1.image       + " at line " + t1.beginLine       + ", column " + t1.beginColumn       + " was not declared");    }    jjtn000.image = t1.image;    jjtn000.beginLine = t1.beginLine;    jjtn000.beginColumn = t1.beginColumn;    return null;  }|   from = number() < DOT > < DOT > to = number()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    jjtn000.image = from.image + " " + to.image;    return null;  }|   t1 = < DOLLAR > regularExpression()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    jjtn000.image = t1.image;    return null;  }|   t1 = < OP > sortExpression() t2 = < CP >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    jjtn000.image = t1.image + t2.image;    return null;  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}void simpleSortExpression()                 :{/*@bgen(jjtree) sortExpression */
  ASTsortExpression jjtn000 = new ASTsortExpression(JJTSORTEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) sortExpression */
  try {
/*@egen*/  simpleAdditiveSortExpression()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}void simpleAdditiveSortExpression()                         :{/*@bgen(jjtree) additiveSortExpression */
  ASTadditiveSortExpression jjtn000 = new ASTadditiveSortExpression(JJTADDITIVESORTEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  jjtn000.image = "+";}{/*@bgen(jjtree) additiveSortExpression */
  try {
/*@egen*/  simpleMultiplicativeSortExpression()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}void simpleMultiplicativeSortExpression()                               :{/*@bgen(jjtree) multiplicativeSortExpression */
  ASTmultiplicativeSortExpression jjtn000 = new ASTmultiplicativeSortExpression(JJTMULTIPLICATIVESORTEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) multiplicativeSortExpression */
  try {
/*@egen*/  simpleUnarySortExpression()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}void simpleUnarySortExpression()                      :{/*@bgen(jjtree) unarySortExpression */
  ASTunarySortExpression jjtn000 = new ASTunarySortExpression(JJTUNARYSORTEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  Token t1;}{/*@bgen(jjtree) unarySortExpression */
  try {
/*@egen*/  t1 = < IDENTIFIER >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    if (!sortNameToExpression.containsKey(t1.image))    {      throw new ParseException("Sort " + t1.image       + " at line " + t1.beginLine       + ", column " + t1.beginColumn       + " was not declared");    }    jjtn000.image = t1.image;    jjtn000.beginLine = t1.beginLine;    jjtn000.beginColumn = t1.beginColumn;  }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}Token specialSortExpression()       :{  Token t;}{  LOOKAHEAD(< IDENTIFIER > < OP > < VARIABLE > < CP >)  simpleSortExpression() < OP > t = < VARIABLE > < CP >  {    return t;  }| sortExpression()  {    return null;  }}HashMap < String, Integer > specialSortExpressionList()                     :{/*@bgen(jjtree) sortExpressionList */
  ASTsortExpressionList jjtn000 = new ASTsortExpressionList(JJTSORTEXPRESSIONLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  HashMap < String, Integer > variableMapping   = new HashMap < String, Integer > ();  int agr = 0;  Token t;}{/*@bgen(jjtree) sortExpressionList */
  try {
/*@egen*/  t = specialSortExpression()  {    if (t != null)    {      variableMapping.put(t.image, agr);    }    agr++;  }  (    < COMMA > t = specialSortExpression()    {      if (t != null)      {        variableMapping.put(t.image, agr);      }      agr++;    }  )*/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    return variableMapping;  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}Token number()       :{  Token t;}{  t = < POSITIVE_INTEGER >  {    return t;  }| t = < ZERO >  {    return t;  }| t = < NONZERODIGIT >  {    return t;  }|   t = < IDENTIFIER >  {    if (!constantsMapping.containsKey(t.image))    {      throw new       ParseException("ERROR: Constant \"" + t.image + "\" at line " + t.beginLine + ", column" + t.beginColumn +       " was not defined");      //return t;
    }    else    {      t.image = constantsMapping.get(t.image).toString();      return t;    }  }}void predicateDeclarations() :{/*@bgen(jjtree) predicateDeclarations */
  ASTpredicateDeclarations jjtn000 = new ASTpredicateDeclarations(JJTPREDICATEDECLARATIONS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) predicateDeclarations */
  try {
/*@egen*/  < PREDDEFKEYWORD >  (    predicateDeclaration()  )*/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    for (String sortName : sortNameToExpression.keySet())    {      if (predicateArgumentSorts.containsKey(sortName))      {        throw new         ParseException("ERROR: Sort name \"" + sortName + "\" is also a name of one of declared predicates");      }      predicateArgumentSorts.put(sortName, new ArrayList < String > ());      predicateArgumentSorts.get(sortName).add(sortName);    }  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}void predicateDeclaration() :{/*@bgen(jjtree) predicateDeclaration */
  ASTpredicateDeclaration jjtn000 = new ASTpredicateDeclaration(JJTPREDICATEDECLARATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  Token t;  ArrayList < String > arguments = new ArrayList < String > ();}{/*@bgen(jjtree) predicateDeclaration */
  try {
/*@egen*/  t = < IDENTIFIER >  {    if (predicateArgumentSorts.containsKey(t.image))    {      throw new ParseException("Line " + t.beginLine + ": " + "predicate " + t.image + " was already declared");    }  }  < OP >  (    arguments = identifierList()  )?  {
    predicateArgumentSorts.put(t.image, arguments);  }  < CP > < DOT >/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}ArrayList < String > identifierList() :{/*@bgen(jjtree) identifierList */
  ASTidentifierList jjtn000 = new ASTidentifierList(JJTIDENTIFIERLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  ArrayList < String > result = new ArrayList < String > ();  Token t;}{/*@bgen(jjtree) identifierList */
  try {
/*@egen*/  t = < IDENTIFIER >  {
     if(!sortNameToExpression.containsKey(t.image))
       {
        throw new ParseException("Line " + t.beginLine + ", column "+t.beginColumn+": " + "sort \"" + t.image + "\" was not defined");
       }   
        result.add(t.image);  }  (    < COMMA > t = < IDENTIFIER >    {      result.add(t.image);    }  )*/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    return result;  }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}SimpleNode programRules() :{/*@bgen(jjtree) programRules */
  ASTprogramRules jjtn000 = new ASTprogramRules(JJTPROGRAMRULES);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) programRules */
  try {
/*@egen*/  < PROGRULDEFKEYWORD >  (    programRule()  )*/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    return jjtn000;  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}SimpleNode programRule() :{/*@bgen(jjtree) programRule */
  ASTprogramRule jjtn000 = new ASTprogramRule(JJTPROGRAMRULE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  Token t;  SimpleNode n;}{/*@bgen(jjtree) programRule */
  try {
/*@egen*/  LOOKAHEAD(2)  t = label()  {    jjtn000.beginLine = t.beginLine;    jjtn000.beginColumn = t.beginColumn;    jjtn000.setLabel(t.image);    if (crRuleLabels.contains(t.image))    {      throw new ParseException("cr-rule label " + t.image + " at line " + t.beginLine +       " column " + t.beginColumn + " occures more then once");    }    else    {      crRuleLabels.add(t.image);    }  }  n = unlabeledProgramCrRule()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    jjtn000.beginLine = n.beginLine;    jjtn000.beginColumn = n.beginColumn;    return jjtn000;  }|   n = unlabeledProgramRule()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    jjtn000.beginLine = n.beginLine;    jjtn000.beginColumn = n.beginColumn;    return jjtn000;  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}SimpleNode unlabeledProgramRule() :{/*@bgen(jjtree) unlabeledProgramRule */
  ASTunlabeledProgramRule jjtn000 = new ASTunlabeledProgramRule(JJTUNLABELEDPROGRAMRULE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  SimpleNode n;  Token from, to, sep;}{/*@bgen(jjtree) unlabeledProgramRule */
  try {
/*@egen*/  LOOKAHEAD(predSymbol() number() < DOT >)  n = predSymbol() from = number() < DOT > < DOT > to = number() < CP > < DOT >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/ //can be body here after safety fix!
  {    jjtn000.beginLine = n.beginLine;    jjtn000.beginColumn = n.beginColumn;    jjtn000.image = n.image + " " + from.image + " " + to.image;    return jjtn000;  }|   n = head() sep = exBody()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    jjtn000.image = sep.image;    jjtn000.beginLine = n.beginLine;    jjtn000.beginColumn = n.beginColumn;    return jjtn000;  }|   sep = < ORRSEP >  {    jjtn000.image = sep.image;    jjtn000.beginLine = sep.beginLine;    jjtn000.beginColumn = sep.beginColumn;  }  body() < DOT >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    return jjtn000;  }|   sep = < CRRSEP >  {    jjtn000.beginLine = sep.beginLine;    jjtn000.beginColumn = sep.beginColumn;    jjtn000.image = sep.image;  }  body() < DOT >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    return jjtn000;  }|   sep = < WEAKSEP >  {    jjtn000.beginLine = sep.beginLine;    jjtn000.beginColumn = sep.beginColumn;    jjtn000.image = sep.image;  }  body() < DOT > [ constraintParams() ]/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    return jjtn000;  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}void constraintParams() :{/*@bgen(jjtree) constraintParams */
  ASTconstraintParams jjtn000 = new ASTconstraintParams(JJTCONSTRAINTPARAMS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  Token t0;  Token t1 = null, t2 = null, t3 = null, t4 = null, t5 = null;  jjtn000.image = "";}{/*@bgen(jjtree) constraintParams */
  try {
/*@egen*/  t0 = < PARAM_BEGIN >  [    (      t1 = var()    | t2 = number()    )  ]  t5 = < COLON >  [    (      t3 = var()    | t4 = number()    )  ]  < PARAM_END >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    if (t1 == null && t2 == null && t3 == null && t4 == null)    {      throw new ParseException("line " + t0.beginLine + ", column " + t0.beginColumn +       ": weak constraint paramethers cannot both be empty");    }    if (t2 != null)    {      jjtn000.image += t2.image;    }    else if (t1 != null)    {      jjtn000.image += "V";    }    jjtn000.image += t5.image;    if (t4 != null)    {      jjtn000.image += t4.image;    }    else if (t3 != null)    {      jjtn000.image += "V";    }  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}SimpleNode unlabeledProgramCrRule() :{/*@bgen(jjtree) unlabeledProgramCrRule */
  ASTunlabeledProgramCrRule jjtn000 = new ASTunlabeledProgramCrRule(JJTUNLABELEDPROGRAMCRRULE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  SimpleNode n;  Token t;}{/*@bgen(jjtree) unlabeledProgramCrRule */
  try {
/*@egen*/  n = head() t = exCrBody()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    jjtn000.beginLine = n.beginLine;    jjtn000.beginColumn = n.beginColumn;    jjtn000.image = t.image;    return jjtn000;  }|   t = < CRRSEP > body() < DOT >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    jjtn000.beginLine = t.beginLine;    jjtn000.beginColumn = t.beginColumn;    jjtn000.image = t.image;    return jjtn000;  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}Token label()       :{  Token t;}{  t = < IDENTIFIER >   < COLON >  {    return t;  }}Token exBody()       :{  Token t;}{  t = exStandartBody()  {    return t;  }|   t = exCrBody()  {    return t;  }}Token exStandartBody()       :{  Token t;}{  t = < ORRSEP > body() < DOT >  {    return t;  }|   t = < DOT >  {    return new Token(SparcTranslatorConstants.ORRSEP, ":-");  }}Token exCrBody()       :{  Token t;}{  t = < CRRSEP > crBodyWithoutSep()  {    return t;  }}void crBodyWithoutSep()       :{}{  < DOT >|   body() < DOT >}SimpleNode head() :{/*@bgen(jjtree) head */
  ASThead jjtn000 = new ASThead(JJTHEAD);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  SimpleNode n;}{/*@bgen(jjtree) head */
  try {
/*@egen*/  LOOKAHEAD(2)  n = choice_rule()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    jjtn000.beginLine = n.beginLine;    jjtn000.beginColumn = n.beginColumn;    return jjtn000;  }|   n = disjunction()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    jjtn000.beginLine = n.beginLine;    jjtn000.beginColumn = n.beginColumn;    return jjtn000;  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}SimpleNode disjunction() :{/*@bgen(jjtree) disjunction */
  ASTdisjunction jjtn000 = new ASTdisjunction(JJTDISJUNCTION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  SimpleNode n;}{/*@bgen(jjtree) disjunction */
  try {
/*@egen*/  n = nonRelAtom()  {    jjtn000.beginLine = n.beginLine;    jjtn000.beginColumn = n.beginColumn;  }  (    < OR > nonRelAtom()  )*/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    return jjtn000;  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}SimpleNode choice_rule() :{/*@bgen(jjtree) choice_rule */
  ASTchoice_rule jjtn000 = new ASTchoice_rule(JJTCHOICE_RULE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  SimpleNode n1 = null;  Token t;}{/*@bgen(jjtree) choice_rule */
  try {
/*@egen*/  [    n1 = arithmeticTerm() [ rel() ]  ]  t = < OB > choice_elements()   < CB >  [    [ rel() ] arithmeticTerm()  ]/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    if (n1 != null)    {      jjtn000.beginLine = n1.beginLine;      jjtn000.beginColumn = n1.beginColumn;    }    else    {      jjtn000.beginLine = t.beginLine;      jjtn000.beginColumn = t.beginColumn;    }    throw new ParseException("line " + jjtn000.beginLine + ", column " + jjtn000.beginColumn +     ": choice rules are not supported");  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}void choice_elements() :{/*@bgen(jjtree) choice_elements */
  ASTchoice_elements jjtn000 = new ASTchoice_elements(JJTCHOICE_ELEMENTS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) choice_elements */
  try {
/*@egen*/  choice_element()  (    < SEMICOLON > choice_element()  )*/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}void choice_element() :{/*@bgen(jjtree) choice_element */
  ASTchoice_element jjtn000 = new ASTchoice_element(JJTCHOICE_ELEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  SimpleNode n;}{/*@bgen(jjtree) choice_element */
  try {
/*@egen*/  n = nonRelAtom() [ < COLON > extendedSimpleAtomList() ]/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    jjtn000.beginLine = n.beginLine;    jjtn000.beginColumn = n.beginColumn;  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}void extendedSimpleAtomList() :{/*@bgen(jjtree) extendedSimpleAtomList */
  ASTextendedSimpleAtomList jjtn000 = new ASTextendedSimpleAtomList(JJTEXTENDEDSIMPLEATOMLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) extendedSimpleAtomList */
  try {
/*@egen*/  simpleAtom()  (    < COMMA > simpleAtom()  )*/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}void body() :{/*@bgen(jjtree) body */
  ASTbody jjtn000 = new ASTbody(JJTBODY);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) body */
  try {
/*@egen*/  atom()  (    < COMMA > atom()  )*/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}Token var() :{/*@bgen(jjtree) var */
  ASTvar jjtn000 = new ASTvar(JJTVAR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  Token t;}{/*@bgen(jjtree) var */
  try {
/*@egen*/  t = < VARIABLE >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    jjtn000.image = t.image;
    jjtn000.setOriginalImage(t.image);    return t;  }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}SimpleNode nonRelAtom() :{/*@bgen(jjtree) nonRelAtom */
  ASTnonRelAtom jjtn000 = new ASTnonRelAtom(JJTNONRELATOM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  SimpleNode n;}{/*@bgen(jjtree) nonRelAtom */
  try {
/*@egen*/  n = predSymbol()  {    jjtn000.beginLine = n.beginLine;    jjtn000.beginColumn = n.beginColumn;  }  [ termList() < CP > ]/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    return jjtn000;  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}void simpleAtom() :{/*@bgen(jjtree) simpleAtom */
  ASTsimpleAtom jjtn000 = new ASTsimpleAtom(JJTSIMPLEATOM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  SimpleNode n;}{/*@bgen(jjtree) simpleAtom */
  try {
/*@egen*/  LOOKAHEAD(symbolicTerm() rel() symbolicTerm())  symbolicTerm() rel() symbolicTerm()|   LOOKAHEAD(symbolicTerm() rel() var())  symbolicTerm() rel() var()|   LOOKAHEAD(arithmeticTerm() rel() arithmeticTerm())  arithmeticTerm() rel() arithmeticTerm()|   LOOKAHEAD(var() rel() symbolicTerm())  var() rel() symbolicTerm()|   LOOKAHEAD(arithmeticTerm() eqrel() symbolicTerm())  arithmeticTerm() eqrel() symbolicTerm()|   LOOKAHEAD(symbolicTerm() eqrel() arithmeticTerm())  symbolicTerm() eqrel() arithmeticTerm()|   n = extendedNonRelAtom()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    jjtn000.image = n.image;  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}SimpleNode extendedNonRelAtom() :{/*@bgen(jjtree) extendedNonRelAtom */
  ASTextendedNonRelAtom jjtn000 = new ASTextendedNonRelAtom(JJTEXTENDEDNONRELATOM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  Token t;  jjtn000.image = "";}{/*@bgen(jjtree) extendedNonRelAtom */
  try {
/*@egen*/  [    t = < NOT >    {      jjtn000.image = t.image;    }  ]  predSymbol() [ termList() < CP > ]/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    return jjtn000;  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}SimpleNode addOp()       :{  Token t;  SimpleNode n = new SimpleNode(0);}{  t = < PLUS >  {    n.image = t.image;    return n;  }|   t = < MINUS >  {    n.image = t.image;    return n;  }}SimpleNode multOp()       :{  Token t;  SimpleNode n = new SimpleNode(0);}{  t = < MULT >  {    n.image = t.image;    return n;  }|   t = < MOD >  {    n.image = t.image;    return n;  }|   t = < DIV >  {    n.image = t.image;    return n;  }}SimpleNode arithmeticTerm() :{/*@bgen(jjtree) arithmeticTerm */
  ASTarithmeticTerm jjtn000 = new ASTarithmeticTerm(JJTARITHMETICTERM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  SimpleNode n;}{/*@bgen(jjtree) arithmeticTerm */
  try {
/*@egen*/  n = additiveArithmeticTerm()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    jjtn000.beginLine = n.beginLine;    jjtn000.beginColumn = n.beginColumn;    return jjtn000;  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}SimpleNode atomicArithmeticTerm() :{/*@bgen(jjtree) atomicArithmeticTerm */
  ASTatomicArithmeticTerm jjtn000 = new ASTatomicArithmeticTerm(JJTATOMICARITHMETICTERM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  Token t;}{/*@bgen(jjtree) atomicArithmeticTerm */
  try {
/*@egen*/  t = number()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    jjtn000.image = t.image;    jjtn000.beginLine = t.beginLine;    jjtn000.beginColumn = t.beginColumn;    return jjtn000;  }|   t = var()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    jjtn000.image = t.image;    jjtn000.beginLine = t.beginLine;    jjtn000.beginColumn = t.beginColumn;    return jjtn000;  }|   t = < OP > arithmeticTerm() < CP >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    jjtn000.image = t.image;    jjtn000.beginLine = t.beginLine;    jjtn000.beginColumn = t.beginColumn;    return jjtn000;  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}SimpleNode additiveArithmeticTerm() :{/*@bgen(jjtree) additiveArithmeticTerm */
  ASTadditiveArithmeticTerm jjtn000 = new ASTadditiveArithmeticTerm(JJTADDITIVEARITHMETICTERM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  SimpleNode n;  jjtn000.image = "+";}{/*@bgen(jjtree) additiveArithmeticTerm */
  try {
/*@egen*/  n = multiplicativeArithmeticTerm()  {    jjtn000.beginLine = n.beginLine;    jjtn000.beginColumn = n.beginColumn;  }  (    n = addOp()    {      jjtn000.image += n.image;    }    multiplicativeArithmeticTerm()  )*/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    return jjtn000;  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}SimpleNode multiplicativeArithmeticTerm() :{/*@bgen(jjtree) multiplicativeArithmeticTerm */
  ASTmultiplicativeArithmeticTerm jjtn000 = new ASTmultiplicativeArithmeticTerm(JJTMULTIPLICATIVEARITHMETICTERM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  SimpleNode n;  jjtn000.image = "";}{/*@bgen(jjtree) multiplicativeArithmeticTerm */
  try {
/*@egen*/  n = atomicArithmeticTerm()  {    jjtn000.beginLine = n.beginLine;    jjtn000.beginColumn = n.beginColumn;  }  (    n = multOp()    {      jjtn000.image += n.image;    }    atomicArithmeticTerm()  )*/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    return jjtn000;  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}SimpleNode symbolicFunction() :{/*@bgen(jjtree) symbolicFunction */
  ASTsymbolicFunction jjtn000 = new ASTsymbolicFunction(JJTSYMBOLICFUNCTION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  Token t;}{/*@bgen(jjtree) symbolicFunction */
  try {
/*@egen*/  t = < IDENTIFIER_WITH_OP >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    jjtn000.image = t.image;    jjtn000.beginColumn = t.beginColumn;    jjtn000.beginLine = t.beginLine;    return jjtn000;  }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}SimpleNode symbolicConstant() :{/*@bgen(jjtree) symbolicConstant */
  ASTsymbolicConstant jjtn000 = new ASTsymbolicConstant(JJTSYMBOLICCONSTANT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  Token t;}{/*@bgen(jjtree) symbolicConstant */
  try {
/*@egen*/  t = < IDENTIFIER >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    jjtn000.image = t.image;    jjtn000.beginLine = t.beginLine;    jjtn000.beginColumn = t.beginColumn;    return jjtn000;  }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}SimpleNode symbolicTerm() :{/*@bgen(jjtree) symbolicTerm */
  ASTsymbolicTerm jjtn000 = new ASTsymbolicTerm(JJTSYMBOLICTERM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  SimpleNode n;}{/*@bgen(jjtree) symbolicTerm */
  try {
/*@egen*/  n = symbolicConstant()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    jjtn000.beginLine = n.beginLine;    jjtn000.beginColumn = n.beginColumn;    return jjtn000;  }|   n = symbolicFunction()  {    jjtn000.beginLine = n.beginLine;    jjtn000.beginColumn = n.beginColumn;  }  termList() < CP >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    return jjtn000;  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}SimpleNode term() :{/*@bgen(jjtree) term */
  ASTterm jjtn000 = new ASTterm(JJTTERM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  SimpleNode n;  Token t;  jjtn000.image = "";}{/*@bgen(jjtree) term */
  try {
/*@egen*/  LOOKAHEAD(symbolicTerm())  n = symbolicTerm()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    jjtn000.beginLine = n.beginLine;    jjtn000.beginColumn = n.beginColumn;
    return jjtn000;  }| LOOKAHEAD(var() (< CP >| < COMMA >))  t = var()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    //System.out.println("t.image");
    jjtn000.image = t.image;    jjtn000.beginLine = t.beginLine;    jjtn000.beginColumn = t.beginColumn;
    return jjtn000;  }| n = arithmeticTerm()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    jjtn000.beginLine = n.beginLine;    jjtn000.beginColumn = n.beginColumn;
    return jjtn000;  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}void termList() :{/*@bgen(jjtree) termList */
  ASTtermList jjtn000 = new ASTtermList(JJTTERMLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) termList */
  try {
/*@egen*/  term()  (    < COMMA > term()  )*/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}Token rel()       :{  Token t;}{  t = < EQ >  {    return t;  }| t = < NOTEQ >  {    return t;  }| t = < GT >  {    return t;  }| t = < GTEQ >  {    return t;  }| t = < SM >  {    return t;  }| t = < SMEQ >  {    return t;  }}Token eqrel()       :{  Token t;}{  t = < EQ >  {    return t;  }| t = < NOTEQ >  {    return t;  }}SimpleNode predSymbol() :{/*@bgen(jjtree) predSymbol */
  ASTpredSymbol jjtn000 = new ASTpredSymbol(JJTPREDSYMBOL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  Token t;}{/*@bgen(jjtree) predSymbol */
  try {
/*@egen*/  t = < IDENTIFIER >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    jjtn000.image = t.image;    jjtn000.beginLine = t.beginLine;    jjtn000.beginColumn = t.beginColumn;    return jjtn000;  }|   t = < IDENTIFIER_WITH_OP >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    jjtn000.image = t.image.substring(0, t.image.length() - 1);    if (sortNameToExpression.containsKey(jjtn000.image))    {      generatingSorts.add(jjtn000.image);    }    jjtn000.beginLine = t.beginLine;    jjtn000.beginColumn = t.beginColumn;    return jjtn000;  }| t = < NEGATIVE_ATOM_WITH_OP >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    jjtn000.negative = true;    jjtn000.image = t.image.substring(1, t.image.length() - 1);    jjtn000.beginLine = t.beginLine;    jjtn000.beginColumn = t.beginColumn;    return jjtn000;  }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}void atom() :{/*@bgen(jjtree) atom */
  ASTatom jjtn000 = new ASTatom(JJTATOM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  Token t1;}{/*@bgen(jjtree) atom */
  try {
/*@egen*/  LOOKAHEAD([ arithmeticTerm() rel() ] aggregateFunction())  aggregate()|   LOOKAHEAD(symbolicTerm() rel() symbolicTerm())  symbolicTerm() t1 = rel() symbolicTerm()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    jjtn000.image = t1.image;  }|   LOOKAHEAD(symbolicTerm() rel() var())  symbolicTerm() t1 = rel() var()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    jjtn000.image = t1.image;  }|   LOOKAHEAD(var() rel() symbolicTerm())  var() t1 = rel() symbolicTerm()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    jjtn000.image = t1.image;  }|   LOOKAHEAD(arithmeticTerm() eqrel() symbolicTerm())  arithmeticTerm() t1 = eqrel() symbolicTerm()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    jjtn000.image = t1.image;  }|   LOOKAHEAD(symbolicTerm() eqrel() arithmeticTerm())  symbolicTerm() t1 = eqrel() arithmeticTerm()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    jjtn000.image = t1.image;  }|   LOOKAHEAD(arithmeticTerm() rel() arithmeticTerm())  arithmeticTerm() t1 = rel() arithmeticTerm()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    jjtn000.image = t1.image;  }|   extendedNonRelAtom()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}void aggregate() :{/*@bgen(jjtree) aggregate */
  ASTaggregate jjtn000 = new ASTaggregate(JJTAGGREGATE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  Token t1 = null, t2 = null;  jjtn000.image = "";}{/*@bgen(jjtree) aggregate */
  try {
/*@egen*/  [ arithmeticTerm() t1 = rel() ] aggregateFunction()   < OB > aggregateElements()   < CB > [ t2 = rel() arithmeticTerm() ]/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    if (t1 != null)    {      jjtn000.image += "L" + t1.image;    }    if (t2 != null)    {      jjtn000.image += "R" + t2.image;    }  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}void aggregateElements() :{/*@bgen(jjtree) aggregateElements */
  ASTaggregateElements jjtn000 = new ASTaggregateElements(JJTAGGREGATEELEMENTS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) aggregateElements */
  try {
/*@egen*/  aggregateElement()  (    < SEMICOLON > aggregateElement()  )*/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}void aggregateElement() :{/*@bgen(jjtree) aggregateElement */
  ASTaggregateElement jjtn000 = new ASTaggregateElement(JJTAGGREGATEELEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  SimpleNode n;}{/*@bgen(jjtree) aggregateElement */
  try {
/*@egen*/  (    LOOKAHEAD(2)    n = nonRelAtom()  | n = arithmeticTerm()  )  (    < COMMA >    (      LOOKAHEAD(2)      nonRelAtom()    | arithmeticTerm()    )  )*  [ < COLON > extendedSimpleAtomList() ]/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    jjtn000.beginLine = n.beginLine;    jjtn000.beginColumn = n.beginColumn;  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}void aggregateFunction() :{/*@bgen(jjtree) aggregateFunction */
  ASTaggregateFunction jjtn000 = new ASTaggregateFunction(JJTAGGREGATEFUNCTION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  Token t;}{/*@bgen(jjtree) aggregateFunction */
  try {
/*@egen*/  t = < AGGREGATE_COUNT >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    jjtn000.image = t.image;  }|   t = < AGGREGATE_MAX >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    jjtn000.image = t.image;  }|   t = < AGGREGATE_MIN >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    jjtn000.image = t.image;  }|   t = < AGGREGATE_SUM >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    jjtn000.image = t.image;  }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}void atomSequence() :{/*@bgen(jjtree) atomSequence */
  ASTatomSequence jjtn000 = new ASTatomSequence(JJTATOMSEQUENCE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) atomSequence */
  try {
/*@egen*/  atom()  (    < COMMA > atom()  )*/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}void characterRegularExpression() :{/*@bgen(jjtree) characterRegularExpression */
  ASTcharacterRegularExpression jjtn000 = new ASTcharacterRegularExpression(JJTCHARACTERREGULAREXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) characterRegularExpression */
  try {
/*@egen*//*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {}/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}void directives(ArrayList < String > directives)       :{}{  (    directive(directives)  )*  {    addBuiltInSorts();  }}void directive(ArrayList < String > directives)       :{  Token t, t1, t2, t3, t4;}{  t = < MAXINTDIRECTIVE > t1 = < EQ > t2 = number() t3 = < DOT >  {    BuiltInSorts.setMaxInt(Integer.parseInt(t2.image));    directives.add(t.image + t1.image + t2.image + t3.image);  }|   t = < CONSTDIRECTIVE > t1 = < IDENTIFIER > t2 = < EQ > t3 = number() t4 = < DOT >  {    directives.add(t.image + " " + t1.image + t2.image + t3.image + t4.image);    constantsMapping.put(t1.image, Long.parseLong(t3.image));  }}
